name: build-macos-bootstrapper

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to build (e.g., 1.2.3); leave empty to use VERSION file or tag"
        required: false
  push:
    tags:
      - 'v*'

jobs:
  build-sign-notarize:
    runs-on: macos-latest
    timeout-minutes: 60
    env:
      KEYCHAIN: build.keychain
      KEYCHAIN_PASSWORD: ${{ secrets.MAC_KEYCHAIN_PASSWORD }}
      P12_BASE64: ${{ secrets.MAC_CERT_P12 }}
      P12_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD }}
      SIGN_IDENTITY_INSTALLER: ${{ secrets.MAC_CERT_IDENTITY_INSTALLER }}
      NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
      NOTARY_API_ISSUER_ID: ${{ secrets.NOTARY_API_ISSUER_ID }}
      NOTARY_API_KEY_BASE64: ${{ secrets.NOTARY_API_KEY_BASE64 }}
      # Optional: sign DMG (less critical than PKG signing)
      SIGN_DMG_IDENTITY: ${{ secrets.MAC_CERT_IDENTITY_APPLICATION }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Node (optional for frontend)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Determine version
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${{ github.event.inputs.version || '' }}" ]]; then
            V="${{ github.event.inputs.version }}"
          elif [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            # strip leading 'v' if present
            V="${GITHUB_REF_NAME#v}"
          elif [[ -f VERSION ]]; then
            V=$(awk 'NR==1{print;exit}' VERSION || echo "1.0.0")
          else
            V="1.0.0"
          fi
          echo "version=$V" >> "$GITHUB_OUTPUT"
          echo "Will build version: $V"

      - name: Check if signing is available
        id: check_signing
        shell: bash
        run: |
          # Check certificate by testing if P12_BASE64 has significant length (base64 cert is >1000 chars)
          if [[ ${#P12_BASE64} -gt 100 ]]; then
            echo "has_cert=true" >> "$GITHUB_OUTPUT"
            echo "✅ Certificate available (${#P12_BASE64} chars) - will sign packages"
          else
            echo "has_cert=false" >> "$GITHUB_OUTPUT"
            echo "⚠️ No certificate or too short (${#P12_BASE64} chars) - building unsigned packages"
          fi

      - name: Create and unlock temporary keychain
        if: steps.check_signing.outputs.has_cert == 'true'
        shell: bash
        run: |
          set -euo pipefail
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
          security set-keychain-settings -lut 21600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
          security list-keychains -s "$KEYCHAIN" login.keychain

      - name: Import Developer ID Installer certificate
        if: steps.check_signing.outputs.has_cert == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "$P12_BASE64" | base64 --decode > signing.p12
          security import signing.p12 -k "$KEYCHAIN" -P "$P12_PASSWORD" -T /usr/bin/productsign -T /usr/bin/codesign -A
          # Allow codesign/productsign to use private keys without UI prompts
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN"

      - name: Build macOS package (PKG)
        shell: bash
        run: |
          set -euo pipefail
          # Only export signing identity if certificate is available
          if [[ "${{ steps.check_signing.outputs.has_cert }}" == "true" ]]; then
            export SIGN_IDENTITY_INSTALLER
          else
            unset SIGN_IDENTITY_INSTALLER
          fi
          chmod +x scripts/build_pkg.sh scripts/build_bootstrap_dmg.sh build_mac.sh scripts/build_dmg.sh || true
          ./scripts/build_pkg.sh "${{ steps.ver.outputs.version }}"

      - name: Notarize PKG (if signed and API key provided)
        if: steps.check_signing.outputs.has_cert == 'true' && env.NOTARY_API_KEY_ID != '' && env.NOTARY_API_ISSUER_ID != '' && env.NOTARY_API_KEY_BASE64 != ''
        shell: bash
        run: |
          set -euo pipefail
          PKG="dist/TitanScraper-${{ steps.ver.outputs.version }}.pkg"
          echo "$NOTARY_API_KEY_BASE64" | base64 --decode > api_key.p8
          xcrun notarytool submit "$PKG" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER_ID" \
            --wait
          xcrun stapler staple "$PKG"

      - name: Build bootstrap DMG (contains PKG + Install.command)
        shell: bash
        run: |
          set -euo pipefail
          # Only export signing identity if certificate is available
          if [[ "${{ steps.check_signing.outputs.has_cert }}" == "true" ]]; then
            export SIGN_DMG_IDENTITY
          else
            unset SIGN_DMG_IDENTITY
          fi
          ./scripts/build_bootstrap_dmg.sh "${{ steps.ver.outputs.version }}"

      - name: Notarize DMG (if signed and API key provided)
        if: steps.check_signing.outputs.has_cert == 'true' && env.NOTARY_API_KEY_ID != '' && env.NOTARY_API_ISSUER_ID != '' && env.NOTARY_API_KEY_BASE64 != ''
        shell: bash
        run: |
          set -euo pipefail
          DMG="dist/TitanScraper-bootstrap-${{ steps.ver.outputs.version }}.dmg"
          # Re-use api_key.p8
          xcrun notarytool submit "$DMG" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER_ID" \
            --wait
          xcrun stapler staple "$DMG"

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: TitanScraper-bootstrap-${{ steps.ver.outputs.version }}-macos
          path: |
            dist/TitanScraper-bootstrap-${{ steps.ver.outputs.version }}.dmg
            dist/TitanScraper-${{ steps.ver.outputs.version }}.pkg
          if-no-files-found: warn

      - name: Create GitHub Release with assets
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.ver.outputs.version }}"
          DMG="dist/TitanScraper-bootstrap-${VERSION}.dmg"
          PKG="dist/TitanScraper-${VERSION}.pkg"
          
          # Delete existing release if any (for re-runs)
          gh release delete "v${VERSION}-macos" --yes 2>/dev/null || true
          
          # Create new release
          gh release create "v${VERSION}-macos" \
            --title "TitanScraper ${VERSION} - macOS" \
            --notes "macOS installer (unsigned)" \
            --prerelease \
            "$DMG" "$PKG" || echo "Release creation failed, files may be missing"

      - name: Cleanup keychain
        if: always() && steps.check_signing.outputs.has_cert == 'true'
        shell: bash
        run: |
          security delete-keychain "$KEYCHAIN" || true
          rm -f signing.p12 api_key.p8 || true
