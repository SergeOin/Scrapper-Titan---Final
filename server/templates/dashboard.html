<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>LinkedIn Scraper Titan - Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  /* Prevent full-page scrolling; only the posts area will scroll */
  html, body { height:100%; overflow:hidden; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif; margin: 0; padding: 1.5rem; background:#f7f9fb; color:#222; display:flex; flex-direction:column; height:100vh; }
    h1 { margin-top:0; font-size:1.4rem; }
  table { width:100%; border-collapse:collapse; margin-top:1rem; font-size:0.9rem; }
    th, td { padding:0.5rem 0.6rem; border-bottom:1px solid #ddd; vertical-align:middle; }
  th { background:#eef2f5; text-align:left; position:sticky; top:0; z-index:2; }
    tr:hover { background:#f1f7fd; }
    code { background:#eee; padding:2px 4px; border-radius:4px; }
    .meta { display:flex; gap:1rem; flex-wrap:wrap; font-size:0.8rem; margin-top:0.5rem; color:#555; }
    .actions { margin-top:1rem; display:flex; gap:0.6rem; align-items:center; flex-wrap:wrap; }
    button { background:#2563eb; color:white; border:none; padding:0.6rem 1rem; border-radius:6px; cursor:pointer; font-size:0.9rem; transition:background 0.2s ease, color 0.2s ease; }
    button:hover { background:#1d4ed8; }
    button.btn-outline { background:#fff; color:#1e3a8a; border:1px solid #cbd5e1; }
    button.btn-outline:hover { background:#e0ecff; color:#1d4ed8; }
    button.btn-danger { background:#dc2626; }
    button.btn-danger:hover { background:#b91c1c; }
    .badge { display:inline-block; padding:2px 6px; border-radius:4px; background:#e0ecff; font-size:0.7rem; }
    .status-texts { display:flex; flex-direction:column; gap:0.35rem; }
    .status-hint { padding:0.45rem 0.75rem; border-radius:6px; font-size:0.85rem; }
    .status-hint-wait { background:#fefce8; color:#854d0e; }
    .status-hint-ok { background:#dcfce7; color:#166534; }
    .status-hint-error { background:#fee2e2; color:#b91c1c; }
  .icon-btn { background:none; border:none; cursor:pointer; font-size:1.3rem; line-height:1; padding:0.35rem; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; transition:transform 0.15s ease, color 0.2s ease; }
  .icon-btn:focus { outline:2px solid #2563eb33; outline-offset:2px; }
  .icon-btn:hover { transform:translateY(-1px); }
  .favorite-toggle { color:#cbd5e1; }
  .favorite-toggle.active { color:#facc15; }
  .delete-post { color:#dc2626; }
  .delete-post:hover { color:#b91c1c; }
  .actions-cell { display:flex; align-items:center; justify-content:center; gap:0.35rem; height:100%; min-height:2.5rem; }
  th.actions-head, td.actions-cell { text-align:center; vertical-align:middle; }
  /* Ensure actions column content is vertically centered and doesn't wrap */
  td.actions-cell { white-space:nowrap; padding-top:0.5rem; padding-bottom:0.5rem; }
  /* Keep a consistent width for the actions column */
  th.actions-head { width:90px; }
  /* Loading state for action buttons */
  .icon-btn[disabled] { opacity:0.6; cursor:not-allowed; transform:none; }
  .icon-btn.loading { position:relative; color:transparent; }
  .icon-btn.loading::after { content:""; width:14px; height:14px; border:2px solid #cbd5e1; border-top-color:#2563eb; border-radius:50%; animation:spin .8s linear infinite; position:absolute; }
  /* Inline spinner for status banner */
  .inline-spinner { width:14px; height:14px; border:2px solid #86efac; border-top-color:#166534; border-radius:50%; display:inline-block; animation:spin .8s linear infinite; margin-right:6px; vertical-align:middle; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .floating-trash { position:fixed; bottom:1.5rem; right:8.5rem; background:#1e293b; color:#f8fafc; padding:0.6rem 0.9rem; border-radius:999px; display:flex; align-items:center; gap:0.5rem; box-shadow:0 10px 25px rgba(15,23,42,0.25); text-decoration:none; font-size:0.9rem; }
  .floating-trash:hover { background:#0f172a; }
  .floating-trash .count { background:#facc15; color:#1e293b; padding:0 0.6rem; border-radius:999px; font-weight:600; }
  .floating-block { position:fixed; bottom:1.5rem; right:1.5rem; background:#0ea5e9; color:#f0f9ff; padding:0.6rem 0.9rem; border-radius:999px; display:flex; align-items:center; gap:0.5rem; box-shadow:0 10px 25px rgba(14,165,233,0.35); text-decoration:none; font-size:0.9rem; }
  .floating-block:hover { background:#0284c7; }
  .floating-block .icon { display:inline-flex; align-items:center; justify-content:center; }
  .floating-block .icon svg { width:16px; height:16px; display:block; }
  /* Drawer styles */
  .drawer-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.45); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:1000; }
  .drawer { position:fixed; top:0; right:-520px; width:520px; max-width:92vw; height:100%; background:#0b1220; color:#e2e8f0; border-left:1px solid rgba(148,163,184,0.2); box-shadow: -12px 0 30px rgba(0,0,0,0.35); transition:right .22s ease; z-index:1001; display:flex; flex-direction:column; }
  .drawer.open { right:0; }
  .drawer-backdrop.open { opacity:1; pointer-events:auto; }
  .drawer header { display:flex; align-items:center; justify-content:space-between; padding:0.8rem 1rem; border-bottom:1px solid rgba(148,163,184,0.2); }
  .drawer .close-btn { background:#1f2937; color:#e5e7eb; border:none; padding:0.35rem 0.6rem; border-radius:6px; cursor:pointer; font-size:0.85rem; }
  .drawer .close-btn:hover { background:#111827; }
  .drawer .content { flex:1; }
  .drawer .content iframe { width:100%; height:100%; border:0; }
    .footer { margin-top:3rem; font-size:0.7rem; color:#777; }
    form.inline { display:inline; }
    nav.pagination { margin-top:1rem; display:flex; gap:0.4rem; flex-wrap:wrap; }
    nav.pagination a { padding:4px 8px; text-decoration:none; border:1px solid #bbb; border-radius:4px; font-size:0.75rem; color:#222; background:#fff; }
    nav.pagination a.active { background:#2563eb; color:#fff; border-color:#2563eb; }
    nav.pagination a:hover { background:#1d4ed8; color:#fff; }
    .wrap { white-space:pre-wrap; word-break:break-word; }
    /* Hide legacy pagination for infinite scroll UX */
    nav.pagination { display:none !important; }
  /* Infinite loader */
  #infiniteLoader { display:none; align-items:center; justify-content:center; gap:.5rem; color:#334155; font-size:.85rem; padding:1rem 0; }
    #infiniteLoader .spinner { width:16px; height:16px; border:2px solid #cbd5e1; border-top-color:#2563eb; border-radius:50%; animation:spin .8s linear infinite; }
  /* End-of-list */
  #endOfList { display:none; text-align:center; color:#475569; font-size:.85rem; padding:0.25rem 0 1.25rem; }
  /* Scroll container for posts only */
  #postsScroll { flex:1; overflow:auto; margin-top:.5rem; background:#fff; border:1px solid #e2e8f0; border-radius:8px; padding:0 .5rem; }
  #postsScroll table { margin-top:.5rem; }
    /* Neutral header link styling (no blue, no underline) */
    th a { color:#222; text-decoration:none; }
    th a:visited { color:#222; }
    th a:hover { text-decoration:none; }
    /* Inline badges and sublines */
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:.7rem; line-height:1; border:1px solid #cbd5e1; background:#eef2f5; color:#334155; }
    .pill-opp { background:#dcfce7; border-color:#86efac; color:#166534; font-weight:600; }
    .pill-intent-rp { background:#1e3a8a; color:#fff; border-color:#1e3a8a; font-weight:600; }
    .pill-intent-autre { background:#64748b; color:#fff; border-color:#64748b; }
    .meta-sub { display:block; font-size:.75rem; color:#64748b; margin-top:2px; }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:space-between; gap:1rem;">
    <h1 style="margin:0;">LinkedIn Scraper Titan</h1>
    <div class="actions" style="margin-top:0;">
      <form id="exportForm" class="inline" action="/export/excel" method="get">
        <input type="hidden" name="q" value="{{ q or '' }}" />
        <input type="hidden" name="sort_by" value="{{ sort_by }}" />
        <input type="hidden" name="sort_dir" value="{{ sort_dir }}" />
        <input type="hidden" name="page" value="1" />
  <button type="submit" class="btn-outline">Exporter au format Excel</button>
      </form>
      <button id="logoutBtn" type="button" class="btn-outline">Se d√©connecter</button>
    </div>
  </div>

  <div id="statusContainer" data-interval="{{ autonomous_interval or 0 }}" data-init-wait="{{ login_initial_wait_seconds or 120 }}" style="margin-top:0.75rem; font-size:0.9rem; display:flex; align-items:center; gap:.75rem;">
  <div id="statusHint" class="status-hint status-hint-wait" aria-live="polite"><span class="inline-spinner" aria-hidden="true"></span>Cycle en cours‚Ä¶</div>
  </div>
  <style>
  /* Status line removed; only hint banner remains */
  </style>
  <script>
    // Toast system
    const _toastQ = [];
    function showToast(msg, type='info'){ // type: info|error|success
      let c = document.getElementById('toastContainer');
      if(!c){
        c = document.createElement('div');
        c.id='toastContainer';
        c.style.cssText='position:fixed;top:1rem;right:1rem;display:flex;flex-direction:column;gap:.5rem;z-index:1000;';
        document.body.appendChild(c);
      }
      const div = document.createElement('div');
      div.textContent = msg;
      div.style.cssText='padding:.6rem .9rem;border-radius:6px;font-size:.75rem;box-shadow:0 2px 6px rgba(0,0,0,.15);color:#fff;opacity:0;transform:translateY(-6px);transition:all .25s;';
      const colors = {info:'#2563eb', success:'#15803d', error:'#b91c1c'};
      div.style.background = colors[type]||colors.info;
      c.appendChild(div);
      requestAnimationFrame(()=>{div.style.opacity='1';div.style.transform='translateY(0)';});
      setTimeout(()=>{div.style.opacity='0';div.style.transform='translateY(-6px)'; setTimeout(()=>div.remove(),300);}, 3400);
    }

    // Periodic status ticker (keeps ETA/countdowns fresh without reload)
    let _statusTicker = null;
    function startStatusTicker(){
      if(_statusTicker) return;
      const tick = async ()=>{
        if(document.visibilityState === 'visible'){
          try { await refreshStatus(); } catch(_) {}
        }
      };
      _statusTicker = setInterval(tick, 5000);
    }
    function stopStatusTicker(){ if(_statusTicker){ clearInterval(_statusTicker); _statusTicker=null; } }
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible'){ startStatusTicker(); }
      else { /* optional: keep running but could pause to save CPU */ }
    });

    const hintEl = document.getElementById('statusHint');
    function setHint(text, variant='status-hint-wait'){
      if(!hintEl) return;
      // Plain text (no spinner)
      hintEl.textContent = text;
      hintEl.className = 'status-hint ' + variant;
    }
    function setHintHTML(html, variant='status-hint-wait'){
      if(!hintEl) return;
      hintEl.innerHTML = html;
      hintEl.className = 'status-hint ' + variant;
    }
    function setHintVisible(visible){
      if(!hintEl) return;
      hintEl.style.display = visible ? 'block' : 'none';
    }
    function setHintAppend(text){
      if(!hintEl) return;
      hintEl.innerHTML = text;
    }

    /**
     * Format publication date for display
     * Shows relative time (e.g., "il y a 2 jours") + absolute date
     */
    function formatPublicationDate(publishedAt, collectedAt) {
      const dateVal = publishedAt || collectedAt;
      if (!dateVal) return '‚Äî';
      
      try {
        const pubDate = new Date(dateVal);
        if (isNaN(pubDate.getTime())) return dateVal;
        
        const now = new Date();
        const diffMs = now - pubDate;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        
        let relativeStr = '';
        if (diffMinutes < 1) {
          relativeStr = "√† l'instant";
        } else if (diffMinutes < 60) {
          relativeStr = `il y a ${diffMinutes} min`;
        } else if (diffHours < 24) {
          relativeStr = `il y a ${diffHours}h`;
        } else if (diffDays === 1) {
          relativeStr = 'hier';
        } else if (diffDays < 7) {
          relativeStr = `il y a ${diffDays} jours`;
        } else if (diffDays < 14) {
          relativeStr = 'il y a 1 sem';
        } else if (diffDays < 21) {
          relativeStr = `il y a ${Math.floor(diffDays / 7)} sem`;
        } else {
          relativeStr = `il y a ${Math.floor(diffDays / 7)} sem`;
        }
        
        // Absolute date (short format)
        const absDate = pubDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
        
        // Combine: "il y a 2 jours (15/01)"
        return `<span title="${pubDate.toLocaleString('fr-FR')}">${relativeStr} <small style="color:#888">(${absDate})</small></span>`;
      } catch (_) {
        return dateVal || '‚Äî';
      }
    }

    function updateTrashBadge(count){
      const badge = document.getElementById('trashCountBadge');
      if(!badge) return;
      const value = Number.isFinite(count) ? count : 0;
      badge.textContent = value;
    }

    function updateBlockedBadge(count){
      const badge = document.getElementById('blockedCountBadge');
      if(!badge) return;
      const value = Number.isFinite(count) ? count : 0;
      badge.textContent = value;
    }

    async function refreshBlockedCount(){
      try{
        const r = await fetch('/blocked-accounts/count', { credentials:'include' });
        if(!r.ok) return;
        const data = await r.json();
        updateBlockedBadge(data.count ?? 0);
      }catch(_){ /* ignore */ }
    }

    async function refreshTrashCount(){
      try {
        const r = await fetch('/api/trash/count', { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        updateTrashBadge(data.count ?? 0);
      } catch(_) { /* ignore */ }
    }

    async function handleFavorite(postId, makeFav){
      try {
        const r = await fetch(`/api/posts/${postId}/favorite`, {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ favorite: !!makeFav })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        // some servers may return no body
        try { await r.json(); } catch(_) { /* ignore */ }
        showToast('Statut favori mis √† jour','success');
      } catch(e){
        showToast('Erreur favori: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    async function handleDelete(postId){
      try {
        const r = await fetch(`/api/posts/${postId}/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ delete: true })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        let data = {};
        try { data = await r.json(); } catch(_) { /* ignore */ }
        showToast('Post d√©plac√© dans la corbeille','info');
        if(data && typeof data.trash_count !== 'undefined'){
          updateTrashBadge(data.trash_count);
        }
      } catch(e){
        showToast('Erreur suppression: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    // Event delegation for actions (bind once at document level so it works even if table is rendered later)
    let _actionsDelegationBound = false;
    function setupActionDelegation(){
      if(_actionsDelegationBound) return;
      _actionsDelegationBound = true;
      document.addEventListener('click', async (ev)=>{
        const target = ev.target;
        if(!(target instanceof Element)) return;
        const btn = target.closest('button.favorite-toggle, button.delete-post');
        if(!btn) return;
        ev.preventDefault();
        ev.stopPropagation();
        const id = btn.getAttribute('data-id');
        if(!id) return;
        btn.classList.add('loading');
        btn.setAttribute('disabled','true');
        try {
          if(btn.classList.contains('favorite-toggle')){
            const makeFav = !btn.classList.contains('active');
            await handleFavorite(id, makeFav);
          } else if(btn.classList.contains('delete-post')){
            await handleDelete(id);
          }
        } finally {
          btn.classList.remove('loading');
          btn.removeAttribute('disabled');
        }
      });
    }

    let _initCountdownHandle = null;
    let _initLeft = null;
    // Countdown removed: immediate trigger + spinner feedback instead
    function startInitCountdown(){}
    function stopInitCountdown(){ if(_initCountdownHandle){ clearInterval(_initCountdownHandle); _initCountdownHandle=null; } _initLeft = null; }

    let _autoTriggeredFirstRun = false;
    let _autoPulseHandle = null;
    let _autoPulseBusy = false;
    function ensureAutoPulse(enabled, interval){
      // If server-side autonomous interval is 0, set up a gentle client-side pulse (every 180s)
      if(!enabled) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(interval > 0) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(_autoPulseHandle) return;
      _autoPulseHandle = setInterval(async ()=>{
        if(_autoPulseBusy) return;
        _autoPulseBusy = true;
        try {
          const r = await fetch('/health');
          if(!r.ok){ _autoPulseBusy=false; return; }
          const data = await r.json();
          // Only trigger if scraping enabled and last run not too recent
          const age = typeof data.last_run_age_seconds === 'number' ? data.last_run_age_seconds : 999999;
          if(data.scraping_enabled && age >= 150){
            try {
              const fd = new FormData();
              await fetch('/trigger', { method:'POST', body: fd, headers: { 'X-Trigger-From': 'dashboard' } });
            } catch(_) {}
          }
        } catch(_) { /* ignore */ }
        finally { _autoPulseBusy = false; }
      }, 180000);
    }
    async function refreshStatus(){
      try {
        const r = await fetch('/health');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        // Disabled reasons: hard flag or reload auto-disable (health can expose later if added)
        if(data.scraping_enabled === false && data.disabled_flag){
          setHint('Scraper d√©sactiv√© (mode maintenance)', 'status-hint-wait');
          setHintVisible(true);
          return;
        }
        if(data.playwright_available === false){
          setHint('Mode lecture seule: Playwright indisponible', 'status-hint-error');
          setHintVisible(true);
        }
        const btn = document.getElementById('toggleBtn');
        const enabled = data.scraping_enabled;
        const interval = Number(document.getElementById('statusContainer').dataset.interval || 0);
        const baseText = "Scraper actif - Laissez l'application ouverte pour collecter automatiquement de nouveaux posts.";
        const spinner = '<span class="inline-spinner" aria-hidden="true"></span>';
        let html = '';
        if (enabled) {
          if (data.last_run_age_seconds !== undefined) {
            if (interval > 0) {
              const eta = Math.max(interval - (data.last_run_age_seconds % interval), 1);
              const perMinPosts = (typeof data.last_job_posts === 'number' && data.last_job_posts >= 0) ? (data.last_job_posts * 60 / interval) : null;
              if (perMinPosts !== null) {
                html = `${spinner}${baseText} ¬∑ ~${perMinPosts.toFixed(1)} posts/min`;
              } else {
                html = `${spinner}${baseText}`;
              }
            } else {
              html = `${spinner}${baseText}`;
            }
            ensureAutoPulse(true, interval);
            setHintHTML(html, 'status-hint-ok');
            setHintVisible(true);
          } else {
            // Initial: immediate launch message with spinner (no artificial wait)
            setHintHTML(`${spinner}Cycle en cours‚Ä¶`, 'status-hint-wait');
            setHintVisible(true);
            if (!_autoTriggeredFirstRun) {
              _autoTriggeredFirstRun = true;
              try {
                const fd = new FormData();
                const tr = await fetch('/trigger', { method:'POST', body: fd, headers: { 'X-Trigger-From': 'dashboard' } });
                if (tr.ok) { showToast('Cycle lanc√©','info'); }
              } catch(_) { /* ignore */ }
            }
            ensureAutoPulse(true, interval);
          }
          if (btn) { btn.textContent = 'Mettre en pause'; btn.style.background = '#dc2626'; }
        } else {
          // Paused: show hint as paused
          setHint('Scraper en pause', 'status-hint-wait');
          setHintVisible(true);
          if (btn) { btn.textContent = 'Reprendre'; btn.style.background = '#16a34a'; }
          if (_autoPulseHandle) { clearInterval(_autoPulseHandle); _autoPulseHandle = null; }
        }
        // Append last run info (preserve spinner if present)
        if (enabled && data.last_run && data.last_job_posts !== undefined) {
          try {
            const d = new Date(data.last_run);
            const localeStr = d.toLocaleString('fr-FR', { dateStyle:'short', timeStyle:'short' });
            const current = hintEl.innerHTML;
            setHintHTML(`${current} ¬∑ dernier run: ${localeStr} (${data.last_job_posts} posts)`, hintEl.className.replace('status-hint ','').trim());
          } catch(_) {
            const current = hintEl.innerHTML;
            setHintHTML(`${current} ¬∑ dernier run: ${data.last_run} (${data.last_job_posts} posts)`, hintEl.className.replace('status-hint ','').trim());
          }
        }
      } catch(e){
        // Health unavailable -> show error banner only
        setHint('Statut indisponible ‚Äì v√©rifiez les logs', 'status-hint-error');
        setHintVisible(true);
      }
    }
    async function toggleScraping(){
      const btn = document.getElementById('toggleBtn');
      if (btn) { btn.disabled = true; btn.textContent = 'Veuillez patienter‚Ä¶'; }
      try {
        const r = await fetch('/toggle', { method:'POST', credentials: 'include' });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        await refreshStatus();
        showToast('√âtat mis √† jour','success');
      } catch(e){
        showToast('Erreur toggle: '+e,'error');
      } finally {
        if (btn) { btn.disabled = false; }
        // refreshStatus already set final text
      }
    }
    const _toggleEl = document.getElementById('toggleBtn');
    if (_toggleEl) _toggleEl.addEventListener('click', toggleScraping);
    // Auto refresh posts if a new run detected
    let _lastRunSeen = null;
    async function refreshPosts(){
      try {
        const url = new URL(window.location.href);
        const page = url.searchParams.get('page') || '1';
        const limit = url.searchParams.get('limit') || '20';
        const q = encodeURIComponent(url.searchParams.get('q')||'');
        const sortBy = encodeURIComponent(url.searchParams.get('sort_by')||'');
        const sortDir = encodeURIComponent(url.searchParams.get('sort_dir')||'');
  const r = await fetch(`/api/posts?page=${page}&limit=${limit}&q=${q}&sort_by=${sortBy}&sort_dir=${sortDir}`, { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        const tbody = document.querySelector('table tbody');
        if(!tbody) return;
        if(data.items.length === 0){
          tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;font-size:0.8rem;color:#555;">Aucun r√©sultat pour le moment.</td></tr>';
          return;
        }
        const rows = data.items.map(p=>{
          const txt = (p.text||'');
          const short = txt.length>500? txt.substring(0,500)+'‚Ä¶' : txt;
          const dateFmt = formatPublicationDate(p.published_at, p.collected_at);
          const searchFallback = `https://www.linkedin.com/search/results/content/?keywords=${encodeURIComponent((txt||p.author||'').slice(0,80))}`;
          const permalink = p.permalink ? `<a href="${p.permalink}" target="_blank">ouvrir</a>` : `<a href="${searchFallback}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>`;
          const metierSub = p.metier ? `<div class="meta-sub" title="M√©tier d√©tect√©">${String(p.metier||'').replace(/</g,'&lt;')}</div>` : '';
          const starActive = Number(p.is_favorite || 0) === 1;
          const starClass = starActive ? 'icon-btn favorite-toggle active' : 'icon-btn favorite-toggle';
          const starTitle = starActive ? 'Retirer des favoris' : 'Marquer en favori';
          return `<tr data-post-id="${p._id}">
            <td><code>${p.keyword||''}</code></td>
            <td>${(p.author||'').replace(/\b(\w+\s+\w+)\s+\1\b/gi,'$1')}${metierSub}</td>
            <td>${(p.company&&p.company.toLowerCase()!==String(p.author||'').toLowerCase())?p.company:'‚Äî'}</td>
            <td class="wrap">${short.replace(/</g,'&lt;')}</td>
            <td>${dateFmt}</td>
            <td>${permalink}</td>
            <td class="actions-cell">
              <button type="button" class="${starClass}" data-id="${p._id}" title="${starTitle}">‚òÖ</button>
              <button type="button" class="icon-btn delete-post" data-id="${p._id}" title="Supprimer ce post">üóë</button>
            </td>
          </tr>`;
        }).join('');
        tbody.innerHTML = rows;
        // No need to rebind per-row handlers thanks to event delegation
      } catch(e){ /* silent */ }
    }
      // ---------- Infinite scroll state + renderer ----------
      const _state = {
        page: 1,
        limit: 30,
        q: new URL(window.location.href).searchParams.get('q') || '',
        sort_by: '{{ sort_by }}' || 'collected_at',
        sort_dir: '{{ sort_dir }}' || 'desc',
        loading: false,
        done: false,
      };

      function _rowHTML(p){
        const txt = (p.text||'');
        const short = txt.length>500? txt.substring(0,500)+'‚Ä¶' : txt;
        const dateFmt = formatPublicationDate(p.published_at, p.collected_at);
        const searchFallback = `https://www.linkedin.com/search/results/content/?keywords=${encodeURIComponent((txt||p.author||'').slice(0,80))}`;
        const permalink = p.permalink ? `<a href="${p.permalink}" target="_blank">ouvrir</a>` : `<a href="${searchFallback}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>`;
        const metierSub = p.metier ? `<div class="meta-sub" title="M√©tier d√©tect√©">${String(p.metier||'').replace(/</g,'&lt;')}</div>` : '';
        const starActive = Number(p.is_favorite || 0) === 1;
        const starClass = starActive ? 'icon-btn favorite-toggle active' : 'icon-btn favorite-toggle';
        const starTitle = starActive ? 'Retirer des favoris' : 'Marquer en favori';
        const companyCell = (p.company&&String(p.company).toLowerCase()!==String(p.author||'').toLowerCase())?p.company:'‚Äî';
        return `<tr data-post-id="${p._id}">
          <td><code>${p.keyword||''}</code></td>
          <td>${(p.author||'').replace(/\\b(\\w+\\s+\\w+)\\s+\\1\\b/gi,'$1')}${metierSub}</td>
          <td>${companyCell}</td>
          <td class="wrap">${short.replace(/</g,'&lt;')}</td>
          <td>${dateFmt}</td>
          <td>${permalink}</td>
          <td class="actions-cell">
            <button type="button" class="${starClass}" data-id="${p._id}" title="${starTitle}">‚òÖ</button>
            <button type="button" class="icon-btn delete-post" data-id="${p._id}" title="Supprimer ce post">üóë</button>
          </td>
        </tr>`;
      }

      function _setLoader(visible){
        const el = document.getElementById('infiniteLoader');
        if(el){ el.style.display = visible ? 'flex' : 'none'; }
      }

      function _setEndOfList(visible){
        const el = document.getElementById('endOfList');
        if(el){ el.style.display = visible ? 'block' : 'none'; }
      }

      async function loadNextPage(){
        if(_state.loading || _state.done) return;
        _state.loading = true;
        _setLoader(true);
        try {
          const q = encodeURIComponent(_state.q||'');
          const sortBy = encodeURIComponent(_state.sort_by||'');
          const sortDir = encodeURIComponent(_state.sort_dir||'');
          const r = await fetch(`/api/posts?page=${_state.page}&limit=${_state.limit}&q=${q}&sort_by=${sortBy}&sort_dir=${sortDir}`, { credentials: 'include' });
          if(!r.ok){ _state.done = true; return; }
          const data = await r.json();
          const items = Array.isArray(data.items) ? data.items : [];
          const tbody = document.querySelector('table tbody');
          if(!tbody) return;
          if(_state.page === 1 && items.length === 0){
            tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;font-size:0.8rem;color:#555;">Aucun r√©sultat pour le moment.</td></tr>';
            _state.done = true;
            _setEndOfList(false);
            return;
          }
          if(items.length > 0){
            const html = items.map(_rowHTML).join('');
            if(_state.page === 1 && tbody.children.length > 0){ tbody.innerHTML = ''; }
            const tmp = document.createElement('tbody'); tmp.innerHTML = html; // to avoid doing innerHTML+=
            while(tmp.firstChild){ tbody.appendChild(tmp.firstChild); }
            _state.page += 1;
            if(items.length < _state.limit){ _state.done = true; }
            // hide end-of-list if we just appended more
            _setEndOfList(false);
          } else {
            _state.done = true;
          }
        } catch(e){ /* ignore */ }
        finally {
          _state.loading = false; _setLoader(false);
          // show end-of-list if done and there is at least one row
          try {
            const tbody = document.querySelector('table tbody');
            const hasRows = !!(tbody && tbody.querySelector('tr'));
            _setEndOfList(_state.done && hasRows);
          } catch(_) {}
        }
      }

      function resetAndLoad(){
        const tbody = document.querySelector('table tbody');
        if(tbody) tbody.innerHTML = '';
        _state.page = 1; _state.done = false; _setEndOfList(false); loadNextPage();
      }

      // Override previous refreshPosts to perform a reset reload
      async function refreshPosts(){ resetAndLoad(); }

      // Scroll listener (on posts container only)
      let _scrollBind = false;
      function bindInfiniteScroll(){
        if(_scrollBind) return; _scrollBind = true;
        const scroller = document.getElementById('postsScroll');
        const onScroll = ()=>{
          if(!scroller) return;
          const nearBottom = (scroller.scrollTop + scroller.clientHeight) >= (scroller.scrollHeight - 300);
          if(nearBottom){ loadNextPage(); }
        };
        if(scroller){ scroller.addEventListener('scroll', onScroll); }
      }
    function setupSSE(){
      try {
        const es = new EventSource('/stream');
        es.onmessage = async (ev)=>{
          try {
            const payload = JSON.parse(ev.data);
            if(payload.type === 'job_complete'){
              await refreshPosts();
              await refreshStatus();
              await refreshTrashCount();
              showToast(`Cycle termin√© (${payload.posts} posts)`, 'info');
              // Keep guidance visible in active mode
              setHint('Laissez l\'application ouverte pour collecter automatiquement de nouveaux posts.', 'status-hint-ok');
              setHintVisible(true);
            } else if (payload.type === 'toggle') {
              await refreshStatus();
              showToast(payload.scraping_enabled ? 'Scraper repris' : 'Scraper en pause', payload.scraping_enabled ? 'success' : 'info');
            }
          } catch(e){ /* ignore JSON parse */ }
          if(payload && payload.type === 'purge'){
            await refreshPosts();
            showToast('Base purg√©e ('+ (payload.removed_sqlite||0) +' supprim√©s)', 'success');
          }
        };
        es.onerror = ()=>{
          // Fallback: restart after delay (will rely on polling if fails repeatedly)
          showToast('SSE coup√© - fallback polling','error');
          setHint('Flux SSE interrompu ‚Äì passage en mode polling', 'status-hint-error');
          es.close();
          startPollingFallback();
        };
      } catch(e){
        startPollingFallback();
      }
    }
    let _pollHandle = null;
    function startPollingFallback(){
      if(_pollHandle) return;
      _pollHandle = setInterval(async ()=>{
        try {
          const r = await fetch('/health');
          if(r.ok){
            const data = await r.json();
            if(data.last_run && data.last_run !== _lastRunSeen){
              if(_lastRunSeen !== null){
                await refreshPosts();
                showToast('Nouveaux posts charg√©s (poll)','info');
              }
              _lastRunSeen = data.last_run;
            }
          }
        } catch(_){ }
        refreshStatus();
      }, 10000);
    }
  refreshStatus();
  setupSSE();
  startStatusTicker();
  setupActionDelegation();
  refreshTrashCount();
  refreshBlockedCount();
  setInterval(refreshBlockedCount, 15000);
  // Drawer logic
  const blockBtn = document.getElementById('floatingBlock');
  const drawer = document.getElementById('blockedDrawer');
  const backdrop = document.getElementById('drawerBackdrop');
  const closeBtn = document.getElementById('drawerCloseBtn');
  function openDrawer(){ if(drawer && backdrop){ drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false'); backdrop.classList.add('open'); backdrop.setAttribute('aria-hidden','false'); var cb = document.getElementById('drawerCloseBtn'); if(cb){ try{ cb.focus(); }catch(_){} } } }
  function closeDrawer(){ if(drawer && backdrop){ drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true'); backdrop.classList.remove('open'); backdrop.setAttribute('aria-hidden','true'); } }
  if(blockBtn){ blockBtn.addEventListener('click', (ev)=>{ if(ev instanceof MouseEvent){ if(ev.button !== 0 || ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey){ return; } } ev.preventDefault(); openDrawer(); }); }
  if(closeBtn){ closeBtn.addEventListener('click', ()=> closeDrawer()); }
  if(backdrop){ backdrop.addEventListener('click', ()=> closeDrawer()); }
  document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape'){ closeDrawer(); } });
    // Logout handler
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async ()=>{
        logoutBtn.disabled = true;
        logoutBtn.textContent = 'D√©connexion‚Ä¶';
        try {
          await fetch('/api/session/logout', { method:'POST' });
        } catch(_) { /* ignore */ }
        window.location.href = '/login';
      });
    }
  </script>
  <!-- Search bar placed between status and table -->
  <form id="searchForm" action="/" method="get" style="margin-top:1rem; display:flex; gap:.5rem; align-items:center;">
      <input id="searchInput" type="text" name="q" placeholder="Rechercher (texte, auteur, entreprise, mot-cl√©)" value="{{ q or '' }}" style="flex:1; padding:.5rem .6rem; border:1px solid #cbd5e1; border-radius:6px;" />
    <input type="hidden" name="limit" value="{{ limit }}" />
    <button type="submit">Rechercher</button>
      <button id="clearSearch" type="button" style="font-size:.85rem;">Effacer</button>
  </form>
    <script>
      // Intercept search to avoid full reload
      (function(){
        const form = document.getElementById('searchForm');
        const input = document.getElementById('searchInput');
        const clearBtn = document.getElementById('clearSearch');
        if(form){ form.addEventListener('submit', (ev)=>{ ev.preventDefault(); _state.q = (input && input.value)||''; resetAndLoad(); }); }
        if(clearBtn){ clearBtn.addEventListener('click', ()=>{ if(input){ input.value=''; } _state.q=''; resetAndLoad(); }); }
      })();
    </script>
  <!-- Top-right actions moved into header -->
  <!-- Note: En cas de doublons visibles, ils sont g√©n√©ralement dus √† des posts sans lien canonique (permalink). Le worker applique d√©j√† une d√©duplication stricte par lien puis (auteur + date). -->
  <div id="postsScroll">
  <table>
    <thead>
      <tr>
        {% set nextDir = 'asc' if sort_dir=='desc' else 'desc' %}
  <th><a href="#" data-sort-by="keyword" data-label="Keyword">Keyword</a></th>
  <th><a href="#" data-sort-by="author" data-label="Auteur">Auteur</a></th>
  <th><a href="#" data-sort-by="company" data-label="Entreprise">Entreprise</a></th>
        <th>Contenu du Post</th>
  <th><a href="#" data-sort-by="published_at" data-label="Date">Date</a></th>
  <th>Lien</th>
  <th class="actions-head">Actions</th>
      </tr>
    </thead>
    <tbody>
    {% for post in posts %}
      <tr data-post-id="{{ post._id }}">
        <td><code>{{ post.keyword }}</code></td>
        <td>{{ post.author }}{% if post.metier %}<div class="meta-sub" title="M√©tier d√©tect√©">{{ post.metier }}</div>{% endif %}</td>
  <td>
    {% set cc = post.company_norm or post.company %}
    {% if cc and (cc|lower) != (post.author|lower) %}{{ cc }}{% else %}‚Äî{% endif %}
  </td>
        <td class="wrap">
          {{ post.text[:500] }}{% if post.text|length > 500 %}‚Ä¶{% endif %}
        </td>
  <td>{{ (post.published_at or post.collected_at)|fmt_date }}</td>
          <td>
            {% if post.permalink %}
              <a href="{{ post.permalink }}" target="_blank">ouvrir</a>
            {% else %}
              {# Fallback: LinkedIn search by truncated text/author to let user click anyway #}
              {% set seed = (post.text or post.author or '')[:80] %}
              <a href="https://www.linkedin.com/search/results/content/?keywords={{ seed | urlencode }}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>
            {% endif %}
          </td>
        <td class="actions-cell">
          <button type="button" class="icon-btn favorite-toggle{% if post.is_favorite %} active{% endif %}" data-id="{{ post._id }}" title="Marquer en favori">‚òÖ</button>
          <button type="button" class="icon-btn delete-post" data-id="{{ post._id }}" title="Supprimer ce post">üóë</button>
        </td>
      </tr>
    {% endfor %}
    {% if posts|length == 0 %}
      <tr><td colspan="7" style="text-align:center; font-size:0.8rem; color:#555;">Aucun r√©sultat pour le moment.</td></tr>
    {% endif %}
    </tbody>
  </table>
  <div id="infiniteLoader"><span class="spinner" aria-hidden="true"></span> Chargement‚Ä¶</div>
  <div id="endOfList">Fin de la liste</div>
  </div>
  <script>
    // Sort handling
    (function(){
      const headers = document.querySelectorAll('thead th a[data-sort-by]');
      function updateSortIndicators(){
        headers.forEach(a=>{
          const field = a.getAttribute('data-sort-by');
          const label = a.getAttribute('data-label') || (a.textContent||'').replace(/[\s‚ñ≤‚ñº]+$/,'').trim();
          if(!field){ a.textContent = label; return; }
          if(_state.sort_by === field){
            const arrow = _state.sort_dir === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
            a.textContent = label + arrow;
          } else {
            a.textContent = label;
          }
        });
      }
      // expose for external calls if needed
      window.__updateSortIndicators = updateSortIndicators;
      headers.forEach(a=>{
        a.addEventListener('click', (ev)=>{
          ev.preventDefault();
          const field = a.getAttribute('data-sort-by')||'collected_at';
          if(_state.sort_by === field){ _state.sort_dir = (_state.sort_dir==='asc')?'desc':'asc'; }
          else { _state.sort_by = field; _state.sort_dir = 'desc'; }
          updateSortIndicators();
          resetAndLoad();
        })
      });
      // Initial load & bind scroll
      bindInfiniteScroll();
      // Clear any server-rendered page and start from API for consistency
      updateSortIndicators();
      resetAndLoad();
    })();
  </script>
  <a id="floatingBlock" class="floating-block" href="/blocked" title="G√©rer les comptes LinkedIn bloqu√©s" aria-label="G√©rer les comptes LinkedIn bloqu√©s">
    <span class="icon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
      </svg>
    </span>
    <span id="blockedCountBadge" style="background:#bae6fd;color:#075985;padding:0 0.5rem;border-radius:999px;font-weight:700;">0</span>
  </a>
  <a id="floatingTrash" class="floating-trash" href="/corbeille" title="Ouvrir la corbeille">
    üóëÔ∏è <span class="count" id="trashCountBadge">{{ trash_count }}</span>
  </a>
  <!-- Inline drawer for blocked accounts management -->
  <div id="drawerBackdrop" class="drawer-backdrop" aria-hidden="true"></div>
  <div id="blockedDrawer" class="drawer" role="dialog" aria-modal="true" aria-labelledby="drawerTitle" aria-hidden="true">
    <header>
      <h2 id="drawerTitle" style="margin:0;font-size:1rem;font-weight:600;">Comptes LinkedIn bloqu√©s</h2>
      <button type="button" id="drawerCloseBtn" class="close-btn" aria-label="Fermer">Fermer ‚úï</button>
    </header>
    <div class="content">
      <iframe id="drawerIframe" src="/blocked" title="Gestion des comptes bloqu√©s" loading="lazy"></iframe>
    </div>
  </div>
  
</body>
</html>