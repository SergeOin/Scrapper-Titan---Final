<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>LinkedIn Scraper - Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif; margin: 1.5rem; background:#f7f9fb; color:#222; }
    h1 { margin-top:0; font-size:1.4rem; }
    table { width:100%; border-collapse:collapse; margin-top:1rem; font-size:0.9rem; }
    th, td { padding:0.5rem 0.6rem; border-bottom:1px solid #ddd; vertical-align:top; }
    th { background:#eef2f5; text-align:left; position:sticky; top:0; }
    tr:hover { background:#f1f7fd; }
    code { background:#eee; padding:2px 4px; border-radius:4px; }
    .meta { display:flex; gap:1rem; flex-wrap:wrap; font-size:0.8rem; margin-top:0.5rem; color:#555; }
    .actions { margin-top:1rem; display:flex; gap:0.6rem; align-items:center; flex-wrap:wrap; }
    button { background:#2563eb; color:white; border:none; padding:0.6rem 1rem; border-radius:6px; cursor:pointer; font-size:0.9rem; transition:background 0.2s ease, color 0.2s ease; }
    button:hover { background:#1d4ed8; }
    button.btn-outline { background:#fff; color:#1e3a8a; border:1px solid #cbd5e1; }
    button.btn-outline:hover { background:#e0ecff; color:#1d4ed8; }
    button.btn-danger { background:#dc2626; }
    button.btn-danger:hover { background:#b91c1c; }
    .badge { display:inline-block; padding:2px 6px; border-radius:4px; background:#e0ecff; font-size:0.7rem; }
    .status-texts { display:flex; flex-direction:column; gap:0.35rem; }
    .status-hint { padding:0.45rem 0.75rem; border-radius:6px; font-size:0.85rem; }
    .status-hint-wait { background:#fefce8; color:#854d0e; }
    .status-hint-ok { background:#dcfce7; color:#166534; }
    .status-hint-error { background:#fee2e2; color:#b91c1c; }
  .icon-btn { background:none; border:none; cursor:pointer; font-size:1.3rem; line-height:1; padding:0.35rem; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; transition:transform 0.15s ease, color 0.2s ease; }
  .icon-btn:focus { outline:2px solid #2563eb33; outline-offset:2px; }
  .icon-btn:hover { transform:translateY(-1px); }
  .favorite-toggle { color:#cbd5e1; }
  .favorite-toggle.active { color:#facc15; }
  .delete-post { color:#dc2626; }
  .delete-post:hover { color:#b91c1c; }
  .actions-cell { display:flex; gap:0.35rem; align-items:center; justify-content:center; }
  th.actions-head, td.actions-cell { text-align:center; }
  /* Ensure actions column content is vertically centered and doesn't wrap */
  td.actions-cell { vertical-align:middle; white-space:nowrap; }
  /* Keep a consistent width for the actions column */
  th.actions-head { width:90px; }
  /* Loading state for action buttons */
  .icon-btn[disabled] { opacity:0.6; cursor:not-allowed; transform:none; }
  .icon-btn.loading { position:relative; color:transparent; }
  .icon-btn.loading::after { content:""; width:14px; height:14px; border:2px solid #cbd5e1; border-top-color:#2563eb; border-radius:50%; animation:spin .8s linear infinite; position:absolute; }
  .floating-trash { position:fixed; bottom:1.5rem; right:1.5rem; background:#1e293b; color:#f8fafc; padding:0.6rem 0.9rem; border-radius:999px; display:flex; align-items:center; gap:0.5rem; box-shadow:0 10px 25px rgba(15,23,42,0.25); text-decoration:none; font-size:0.9rem; }
  .floating-trash:hover { background:#0f172a; }
  .floating-trash .count { background:#facc15; color:#1e293b; padding:0 0.6rem; border-radius:999px; font-weight:600; }
    .footer { margin-top:3rem; font-size:0.7rem; color:#777; }
    form.inline { display:inline; }
    nav.pagination { margin-top:1rem; display:flex; gap:0.4rem; flex-wrap:wrap; }
    nav.pagination a { padding:4px 8px; text-decoration:none; border:1px solid #bbb; border-radius:4px; font-size:0.75rem; color:#222; background:#fff; }
    nav.pagination a.active { background:#2563eb; color:#fff; border-color:#2563eb; }
    nav.pagination a:hover { background:#1d4ed8; color:#fff; }
    .wrap { white-space:pre-wrap; word-break:break-word; }
    /* Neutral header link styling (no blue, no underline) */
    th a { color:#222; text-decoration:none; }
    th a:visited { color:#222; }
    th a:hover { text-decoration:none; }
    /* Inline badges and sublines */
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:.7rem; line-height:1; border:1px solid #cbd5e1; background:#eef2f5; color:#334155; }
    .pill-opp { background:#dcfce7; border-color:#86efac; color:#166534; font-weight:600; }
    .meta-sub { display:block; font-size:.75rem; color:#64748b; margin-top:2px; }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:space-between; gap:1rem;">
    <h1 style="margin:0;">LinkedIn Scraper</h1>
    <div class="actions" style="margin-top:0;">
      <form id="exportForm" class="inline" action="/export/excel" method="get">
        <input type="hidden" name="q" value="{{ q or '' }}" />
        <input type="hidden" name="sort_by" value="{{ sort_by }}" />
        <input type="hidden" name="sort_dir" value="{{ sort_dir }}" />
        <input type="hidden" name="page" value="1" />
  <button type="submit" class="btn-outline">Exporter au format Excel</button>
      </form>
      <button id="logoutBtn" type="button" class="btn-outline">Se d√©connecter</button>
    </div>
  </div>

  <div id="statusContainer" data-interval="{{ autonomous_interval or 0 }}" data-init-wait="{{ login_initial_wait_seconds or 120 }}" style="margin-top:0.75rem; font-size:0.9rem; display:flex; align-items:center; gap:.75rem;">
    <div id="statusHint" class="status-hint status-hint-wait" aria-live="polite">Scraper d√©marre, merci de patienter ~2 min</div>
  </div>
  <style>
  /* Status line removed; only hint banner remains */
  </style>
  <script>
    // Toast system
    const _toastQ = [];
    function showToast(msg, type='info'){ // type: info|error|success
      let c = document.getElementById('toastContainer');
      if(!c){
        c = document.createElement('div');
        c.id='toastContainer';
        c.style.cssText='position:fixed;top:1rem;right:1rem;display:flex;flex-direction:column;gap:.5rem;z-index:1000;';
        document.body.appendChild(c);
      }
      const div = document.createElement('div');
      div.textContent = msg;
      div.style.cssText='padding:.6rem .9rem;border-radius:6px;font-size:.75rem;box-shadow:0 2px 6px rgba(0,0,0,.15);color:#fff;opacity:0;transform:translateY(-6px);transition:all .25s;';
      const colors = {info:'#2563eb', success:'#15803d', error:'#b91c1c'};
      div.style.background = colors[type]||colors.info;
      c.appendChild(div);
      requestAnimationFrame(()=>{div.style.opacity='1';div.style.transform='translateY(0)';});
      setTimeout(()=>{div.style.opacity='0';div.style.transform='translateY(-6px)'; setTimeout(()=>div.remove(),300);}, 3400);
    }

    // Periodic status ticker (keeps ETA/countdowns fresh without reload)
    let _statusTicker = null;
    function startStatusTicker(){
      if(_statusTicker) return;
      const tick = async ()=>{
        if(document.visibilityState === 'visible'){
          try { await refreshStatus(); } catch(_) {}
        }
      };
      _statusTicker = setInterval(tick, 5000);
    }
    function stopStatusTicker(){ if(_statusTicker){ clearInterval(_statusTicker); _statusTicker=null; } }
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible'){ startStatusTicker(); }
      else { /* optional: keep running but could pause to save CPU */ }
    });

    const hintEl = document.getElementById('statusHint');
    function setHint(text, variant='status-hint-wait'){
      if(!hintEl) return;
      hintEl.textContent = text;
      hintEl.className = 'status-hint ' + variant;
    }
    function setHintVisible(visible){
      if(!hintEl) return;
      hintEl.style.display = visible ? 'block' : 'none';
    }
    function setHintAppend(text){
      if(!hintEl) return;
      hintEl.innerHTML = text;
    }

    function updateTrashBadge(count){
      const badge = document.getElementById('trashCountBadge');
      if(!badge) return;
      const value = Number.isFinite(count) ? count : 0;
      badge.textContent = value;
    }

    async function refreshTrashCount(){
      try {
        const r = await fetch('/api/trash/count', { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        updateTrashBadge(data.count ?? 0);
      } catch(_) { /* ignore */ }
    }

    async function handleFavorite(postId, makeFav){
      try {
        const r = await fetch(`/api/posts/${postId}/favorite`, {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ favorite: !!makeFav })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        // some servers may return no body
        try { await r.json(); } catch(_) { /* ignore */ }
        showToast('Statut favori mis √† jour','success');
      } catch(e){
        showToast('Erreur favori: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    async function handleDelete(postId){
      try {
        const r = await fetch(`/api/posts/${postId}/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ delete: true })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        let data = {};
        try { data = await r.json(); } catch(_) { /* ignore */ }
        showToast('Post d√©plac√© dans la corbeille','info');
        if(data && typeof data.trash_count !== 'undefined'){
          updateTrashBadge(data.trash_count);
        }
      } catch(e){
        showToast('Erreur suppression: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    // Event delegation for actions (bind once at document level so it works even if table is rendered later)
    let _actionsDelegationBound = false;
    function setupActionDelegation(){
      if(_actionsDelegationBound) return;
      _actionsDelegationBound = true;
      document.addEventListener('click', async (ev)=>{
        const target = ev.target;
        if(!(target instanceof Element)) return;
        const btn = target.closest('button.favorite-toggle, button.delete-post');
        if(!btn) return;
        ev.preventDefault();
        ev.stopPropagation();
        const id = btn.getAttribute('data-id');
        if(!id) return;
        btn.classList.add('loading');
        btn.setAttribute('disabled','true');
        try {
          if(btn.classList.contains('favorite-toggle')){
            const makeFav = !btn.classList.contains('active');
            await handleFavorite(id, makeFav);
          } else if(btn.classList.contains('delete-post')){
            await handleDelete(id);
          }
        } finally {
          btn.classList.remove('loading');
          btn.removeAttribute('disabled');
        }
      });
    }

    let _initCountdownHandle = null;
    let _initLeft = null;
    function startInitCountdown(){
      const cont = document.getElementById('statusContainer');
      if(!cont) return;
      const target = Number(cont.dataset.initWait || 120);
      if(_initCountdownHandle) return; // already running
      if(_initLeft === null){ _initLeft = Math.floor(target); }
      const update = ()=>{
        const left = Math.max(_initLeft ?? 0, 0);
        const m = Math.floor(left/60);
        const s = left%60;
        const parts = [];
        if(m>0) parts.push(m+" min");
        parts.push(s.toString().padStart(2,'0')+" s");
        setHintAppend(`Scraper d√©marre, merci de patienter ~${parts.join(' ')}`);
        if(left<=0){
          clearInterval(_initCountdownHandle);
          _initCountdownHandle=null;
          // Countdown finished but first run may still be in progress
          setHint('Premier cycle en cours‚Ä¶', 'status-hint-wait');
          setHintVisible(true);
          // Try a status refresh shortly after to flip to actif when available
          setTimeout(()=>{ try { refreshStatus(); } catch(_){} }, 1500);
          return;
        }
        _initLeft = left - 1;
      };
      update();
      _initCountdownHandle = setInterval(update, 1000);
    }
    function stopInitCountdown(){ if(_initCountdownHandle){ clearInterval(_initCountdownHandle); _initCountdownHandle=null; } _initLeft = null; }

    let _autoTriggeredFirstRun = false;
    let _autoPulseHandle = null;
    let _autoPulseBusy = false;
    function ensureAutoPulse(enabled, interval){
      // If server-side autonomous interval is 0, set up a gentle client-side pulse (every 180s)
      if(!enabled) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(interval > 0) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(_autoPulseHandle) return;
      _autoPulseHandle = setInterval(async ()=>{
        if(_autoPulseBusy) return;
        _autoPulseBusy = true;
        try {
          const r = await fetch('/health');
          if(!r.ok){ _autoPulseBusy=false; return; }
          const data = await r.json();
          // Only trigger if scraping enabled and last run not too recent
          const age = typeof data.last_run_age_seconds === 'number' ? data.last_run_age_seconds : 999999;
          if(data.scraping_enabled && age >= 150){
            try {
              const fd = new FormData();
              await fetch('/trigger', { method:'POST', body: fd, headers: { 'X-Trigger-From': 'dashboard' } });
            } catch(_) {}
          }
        } catch(_) { /* ignore */ }
        finally { _autoPulseBusy = false; }
      }, 180000);
    }
    async function refreshStatus(){
      try {
        const r = await fetch('/health');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        const btn = document.getElementById('toggleBtn');
        const enabled = data.scraping_enabled;
        const interval = Number(document.getElementById('statusContainer').dataset.interval || 0);
        const base = "Scraper actif - Laissez l'application ouverte pour collecter automatiquement de nouveaux posts.";
        let txt = '';
        if (enabled) {
          if (data.last_run_age_seconds !== undefined) {
            if (interval > 0) {
              const eta = Math.max(interval - (data.last_run_age_seconds % interval), 1);
              const perMinPosts = (typeof data.last_job_posts === 'number' && data.last_job_posts >= 0) ? (data.last_job_posts * 60 / interval) : null;
              if (perMinPosts !== null) {
                // Simplified banner: show avg posts/min only
                txt = `${base} ¬∑ ~${perMinPosts.toFixed(1)} posts/min`;
              } else {
                // If no perMinPosts metric, keep base only (suppress cycles/min + countdown)
                txt = base;
              }
            } else {
              // Active, no server-side interval -> keep guidance banner visible
              txt = base;
            }
            stopInitCountdown();
            ensureAutoPulse(true, interval);
            setHint(txt, 'status-hint-ok');
            setHintVisible(true);
          } else {
            // Initialisation: show countdown and keep hint visible
            setHint('Scraper d√©marre, merci de patienter‚Ä¶', 'status-hint-wait');
            setHintVisible(true);
            startInitCountdown();
            if (!_autoTriggeredFirstRun) {
              _autoTriggeredFirstRun = true;
              try {
                const fd = new FormData();
                const tr = await fetch('/trigger', { method:'POST', body: fd, headers: { 'X-Trigger-From': 'dashboard' } });
                if (tr.ok) { showToast('Premier cycle lanc√©','info'); }
              } catch(_) { /* ignore */ }
            }
            ensureAutoPulse(true, interval);
          }
          if (btn) { btn.textContent = 'Mettre en pause'; btn.style.background = '#dc2626'; }
        } else {
          // Paused: show hint as paused
          setHint('Scraper en pause', 'status-hint-wait');
          setHintVisible(true);
          if (btn) { btn.textContent = 'Reprendre'; btn.style.background = '#16a34a'; }
          stopInitCountdown();
          if (_autoPulseHandle) { clearInterval(_autoPulseHandle); _autoPulseHandle = null; }
        }
        // Append last run info to the hint if available
        if (data.last_run && data.last_job_posts !== undefined) {
          try {
            const d = new Date(data.last_run);
            const localeStr = d.toLocaleString('fr-FR', { dateStyle:'short', timeStyle:'short' });
            setHintAppend(`${hintEl.innerText || hintEl.textContent} ¬∑ dernier run: ${localeStr} (${data.last_job_posts} posts)`);
          } catch(_) {
            setHintAppend(`${hintEl.innerText || hintEl.textContent} ¬∑ dernier run: ${data.last_run} (${data.last_job_posts} posts)`);
          }
        }
      } catch(e){
        // Health unavailable -> show error banner only
        setHint('Statut indisponible ‚Äì v√©rifiez les logs', 'status-hint-error');
        setHintVisible(true);
        stopInitCountdown();
      }
    }
    async function toggleScraping(){
      const btn = document.getElementById('toggleBtn');
      if (btn) { btn.disabled = true; btn.textContent = 'Veuillez patienter‚Ä¶'; }
      try {
        const r = await fetch('/toggle', { method:'POST', credentials: 'include' });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        await refreshStatus();
        showToast('√âtat mis √† jour','success');
      } catch(e){
        showToast('Erreur toggle: '+e,'error');
      } finally {
        if (btn) { btn.disabled = false; }
        // refreshStatus already set final text
      }
    }
    const _toggleEl = document.getElementById('toggleBtn');
    if (_toggleEl) _toggleEl.addEventListener('click', toggleScraping);
    // Auto refresh posts if a new run detected
    let _lastRunSeen = null;
    async function refreshPosts(){
      try {
        const url = new URL(window.location.href);
        const page = url.searchParams.get('page') || '1';
        const limit = url.searchParams.get('limit') || '20';
        const q = encodeURIComponent(url.searchParams.get('q')||'');
        const sortBy = encodeURIComponent(url.searchParams.get('sort_by')||'');
        const sortDir = encodeURIComponent(url.searchParams.get('sort_dir')||'');
  const r = await fetch(`/api/posts?page=${page}&limit=${limit}&q=${q}&sort_by=${sortBy}&sort_dir=${sortDir}`, { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        const tbody = document.querySelector('table tbody');
        if(!tbody) return;
        if(data.items.length === 0){
          tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;font-size:0.8rem;color:#555;">Aucun r√©sultat pour le moment.</td></tr>';
          return;
        }
        const rows = data.items.map(p=>{
          const txt = (p.text||'');
          const short = txt.length>500? txt.substring(0,500)+'‚Ä¶' : txt;
          const dateVal = p.published_at || p.collected_at;
          let dateFmt = '';
          try { dateFmt = new Date(dateVal).toLocaleString('fr-FR',{dateStyle:'short', timeStyle:'short'});} catch(_) { dateFmt = dateVal||''; }
          const searchFallback = `https://www.linkedin.com/search/results/content/?keywords=${encodeURIComponent((txt||p.author||'').slice(0,80))}`;
          const permalink = p.permalink ? `<a href="${p.permalink}" target="_blank">ouvrir</a>` : `<a href="${searchFallback}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>`;
          const status = p.status || '‚Äî';
          const metierSub = p.metier ? `<div class="meta-sub" title="M√©tier d√©tect√©">${String(p.metier||'').replace(/</g,'&lt;')}</div>` : '';
          const oppBadge = p.opportunity ? '<span class="pill pill-opp" title="Signal de recrutement d√©tect√©">Opportunit√©</span> ' : '';
          const starActive = Number(p.is_favorite || 0) === 1;
          const starClass = starActive ? 'icon-btn favorite-toggle active' : 'icon-btn favorite-toggle';
          const starTitle = starActive ? 'Retirer des favoris' : 'Marquer en favori';
          return `<tr data-post-id="${p._id}">
            <td><code>${p.keyword||''}</code></td>
            <td>${(p.author||'').replace(/\b(\w+\s+\w+)\s+\1\b/gi,'$1')}${metierSub}</td>
            <td>${(p.company&&p.company.toLowerCase()!==String(p.author||'').toLowerCase())?p.company:'‚Äî'}</td>
            <td class="wrap">${oppBadge}${short.replace(/</g,'&lt;')}</td>
            <td>${dateFmt}</td>
            <td>${permalink}</td>
            <td>${status}</td>
            <td class="actions-cell">
              <button type="button" class="${starClass}" data-id="${p._id}" title="${starTitle}">‚òÖ</button>
              <button type="button" class="icon-btn delete-post" data-id="${p._id}" title="Supprimer ce post">üóë</button>
            </td>
          </tr>`;
        }).join('');
        tbody.innerHTML = rows;
        // No need to rebind per-row handlers thanks to event delegation
      } catch(e){ /* silent */ }
    }
    function setupSSE(){
      try {
        const es = new EventSource('/stream');
        es.onmessage = async (ev)=>{
          try {
            const payload = JSON.parse(ev.data);
            if(payload.type === 'job_complete'){
              await refreshPosts();
              await refreshStatus();
              await refreshTrashCount();
              showToast(`Cycle termin√© (${payload.posts} posts)`, 'info');
              // Keep guidance visible in active mode
              setHint('Laissez l\'application ouverte pour collecter automatiquement de nouveaux posts.', 'status-hint-ok');
              setHintVisible(true);
            } else if (payload.type === 'toggle') {
              await refreshStatus();
              showToast(payload.scraping_enabled ? 'Scraper repris' : 'Scraper en pause', payload.scraping_enabled ? 'success' : 'info');
            }
          } catch(e){ /* ignore JSON parse */ }
          if(payload && payload.type === 'purge'){
            await refreshPosts();
            showToast('Base purg√©e ('+ (payload.removed_sqlite||0) +' supprim√©s)', 'success');
          }
        };
        es.onerror = ()=>{
          // Fallback: restart after delay (will rely on polling if fails repeatedly)
          showToast('SSE coup√© - fallback polling','error');
          setHint('Flux SSE interrompu ‚Äì passage en mode polling', 'status-hint-error');
          es.close();
          startPollingFallback();
        };
      } catch(e){
        startPollingFallback();
      }
    }
    let _pollHandle = null;
    function startPollingFallback(){
      if(_pollHandle) return;
      _pollHandle = setInterval(async ()=>{
        try {
          const r = await fetch('/health');
          if(r.ok){
            const data = await r.json();
            if(data.last_run && data.last_run !== _lastRunSeen){
              if(_lastRunSeen !== null){
                await refreshPosts();
                showToast('Nouveaux posts charg√©s (poll)','info');
              }
              _lastRunSeen = data.last_run;
            }
          }
        } catch(_){ }
        refreshStatus();
      }, 10000);
    }
  refreshStatus();
  setupSSE();
  startStatusTicker();
  setupActionDelegation();
  refreshTrashCount();
    // Logout handler
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async ()=>{
        logoutBtn.disabled = true;
        logoutBtn.textContent = 'D√©connexion‚Ä¶';
        try {
          await fetch('/api/session/logout', { method:'POST' });
        } catch(_) { /* ignore */ }
        window.location.href = '/login';
      });
    }
  </script>
  <!-- Search bar placed between status and table -->
  <form id="searchForm" action="/" method="get" style="margin-top:1rem; display:flex; gap:.5rem; align-items:center;">
    <input type="text" name="q" placeholder="Rechercher (texte, auteur, entreprise, mot-cl√©)" value="{{ q or '' }}" style="flex:1; padding:.5rem .6rem; border:1px solid #cbd5e1; border-radius:6px;" />
    <input type="hidden" name="limit" value="{{ limit }}" />
    <button type="submit">Rechercher</button>
    {% if q %}
      <a href="/?limit={{ limit }}" style="font-size:.85rem;">Effacer</a>
    {% endif %}
  </form>
  <!-- Top-right actions moved into header -->
  <!-- Note: En cas de doublons visibles, ils sont g√©n√©ralement dus √† des posts sans lien canonique (permalink). Le worker applique d√©j√† une d√©duplication stricte par lien puis (auteur + date). -->
  <table>
    <thead>
      <tr>
        {% set nextDir = 'asc' if sort_dir=='desc' else 'desc' %}
        <th>
          <a href="/?page=1&limit={{ limit }}{% if q %}&q={{ q | urlencode }}{% endif %}&sort_by=keyword&sort_dir={{ 'desc' if sort_by!='keyword' else nextDir }}">Keyword{% if sort_by=='keyword' %} {% if sort_dir=='asc' %}‚ñ≤{% else %}‚ñº{% endif %}{% endif %}</a>
        </th>
        <th>
          <a href="/?page=1&limit={{ limit }}{% if q %}&q={{ q | urlencode }}{% endif %}&sort_by=author&sort_dir={{ 'desc' if sort_by!='author' else nextDir }}">Auteur{% if sort_by=='author' %} {% if sort_dir=='asc' %}‚ñ≤{% else %}‚ñº{% endif %}{% endif %}</a>
        </th>
        <th>
          <a href="/?page=1&limit={{ limit }}{% if q %}&q={{ q | urlencode }}{% endif %}&sort_by=company&sort_dir={{ 'desc' if sort_by!='company' else nextDir }}">Entreprise{% if sort_by=='company' %} {% if sort_dir=='asc' %}‚ñ≤{% else %}‚ñº{% endif %}{% endif %}</a>
        </th>
        <th>Texte</th>
        <th>
          <a href="/?page=1&limit={{ limit }}{% if q %}&q={{ q | urlencode }}{% endif %}&sort_by=published_at&sort_dir={{ 'desc' if sort_by!='published_at' else nextDir }}">Date{% if sort_by=='published_at' %} {% if sort_dir=='asc' %}‚ñ≤{% else %}‚ñº{% endif %}{% endif %}</a>
        </th>
  <th>Lien</th>
  <th>Statut</th>
  <th class="actions-head">Actions</th>
      </tr>
    </thead>
    <tbody>
    {% for post in posts %}
      <tr data-post-id="{{ post._id }}">
        <td><code>{{ post.keyword }}</code></td>
        <td>{{ post.author }}{% if post.metier %}<div class="meta-sub" title="M√©tier d√©tect√©">{{ post.metier }}</div>{% endif %}</td>
  <td>{% if post.company and (post.company|lower) != (post.author|lower) %}{{ post.company }}{% else %}‚Äî{% endif %}</td>
        <td class="wrap">{% if post.opportunity %}<span class="pill pill-opp" title="Signal de recrutement d√©tect√©">Opportunit√©</span> {% endif %}{{ post.text[:500] }}{% if post.text|length > 500 %}‚Ä¶{% endif %}</td>
  <td>{{ (post.published_at or post.collected_at)|fmt_date }}</td>
          <td>
            {% if post.permalink %}
              <a href="{{ post.permalink }}" target="_blank">ouvrir</a>
            {% else %}
              {# Fallback: LinkedIn search by truncated text/author to let user click anyway #}
              {% set seed = (post.text or post.author or '')[:80] %}
              <a href="https://www.linkedin.com/search/results/content/?keywords={{ seed | urlencode }}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>
            {% endif %}
          </td>
  <td>{{ post.status or '‚Äî' }}</td>
        <td class="actions-cell">
          <button type="button" class="icon-btn favorite-toggle{% if post.is_favorite %} active{% endif %}" data-id="{{ post._id }}" title="Marquer en favori">‚òÖ</button>
          <button type="button" class="icon-btn delete-post" data-id="{{ post._id }}" title="Supprimer ce post">üóë</button>
        </td>
      </tr>
    {% endfor %}
    {% if posts|length == 0 %}
      <tr><td colspan="8" style="text-align:center; font-size:0.8rem; color:#555;">Aucun r√©sultat pour le moment.</td></tr>
    {% endif %}
    </tbody>
  </table>
  <nav class="pagination">
    {% for page_num in range(1, total_pages + 1) %}
      <a href="/?page={{ page_num }}&limit={{ limit }}{% if q %}&q={{ q | urlencode }}{% endif %}" class="{% if page_num == page %}active{% endif %}">{{ page_num }}</a>
    {% endfor %}
  </nav>
  <a id="floatingTrash" class="floating-trash" href="/corbeille" title="Ouvrir la corbeille">
    üóëÔ∏è <span class="count" id="trashCountBadge">{{ trash_count }}</span>
  </a>
  
</body>
</html>