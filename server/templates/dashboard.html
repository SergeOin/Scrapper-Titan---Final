<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>LinkedIn Scraper Titan - Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  /* Prevent full-page scrolling; only the posts area will scroll */
  html, body { height:100%; overflow:hidden; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif; margin: 0; padding: 1.5rem; background:#f7f9fb; color:#222; display:flex; flex-direction:column; height:100vh; }
    h1 { margin-top:0; font-size:1.4rem; }
  table { width:100%; border-collapse:collapse; margin-top:1rem; font-size:0.9rem; }
    th, td { padding:0.5rem 0.6rem; border-bottom:1px solid #ddd; vertical-align:middle; }
  th { background:#eef2f5; text-align:left; position:sticky; top:0; z-index:2; }
  th.sortable { cursor:pointer; user-select:none; transition:background 0.15s; }
  th.sortable:hover { background:#dde5ec; }
  th .sort-icon { opacity:0.3; font-size:0.75em; margin-left:4px; }
  th.sort-active .sort-icon { opacity:1; color:#2563eb; }
    tr:hover { background:#f1f7fd; }
    code { background:#eee; padding:2px 4px; border-radius:4px; }
    .meta { display:flex; gap:1rem; flex-wrap:wrap; font-size:0.8rem; margin-top:0.5rem; color:#555; }
    .actions { margin-top:1rem; display:flex; gap:0.6rem; align-items:center; flex-wrap:wrap; }
    button { background:#2563eb; color:white; border:none; padding:0.6rem 1rem; border-radius:6px; cursor:pointer; font-size:0.9rem; transition:background 0.2s ease, color 0.2s ease; }
    button:hover { background:#1d4ed8; }
    button.btn-outline { background:#fff; color:#1e3a8a; border:1px solid #cbd5e1; }
    button.btn-outline:hover { background:#e0ecff; color:#1d4ed8; }
    button.btn-danger { background:#dc2626; }
    button.btn-danger:hover { background:#b91c1c; }
    .badge { display:inline-block; padding:2px 6px; border-radius:4px; background:#e0ecff; font-size:0.7rem; }
    .status-texts { display:flex; flex-direction:column; gap:0.35rem; }
    .status-hint { padding:0.45rem 0.75rem; border-radius:6px; font-size:0.85rem; }
    .status-hint-wait { background:#fefce8; color:#854d0e; }
    .status-hint-ok { background:#dcfce7; color:#166534; }
    .status-hint-error { background:#fee2e2; color:#b91c1c; }
  .icon-btn { background:none; border:none; cursor:pointer; font-size:1.3rem; line-height:1; padding:0.35rem; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; transition:transform 0.15s ease, color 0.2s ease; vertical-align:middle; }
  .icon-btn:focus { outline:2px solid #2563eb33; outline-offset:2px; }
  .icon-btn:hover { transform:translateY(-1px); }
  .favorite-toggle { color:#cbd5e1; }
  .favorite-toggle.active { color:#facc15; }
  .delete-post { color:#dc2626; }
  .delete-post:hover { color:#b91c1c; }
  /* Actions cell: force consistent vertical alignment */
  td.actions-cell { text-align:center !important; vertical-align:middle !important; white-space:nowrap; padding:0.5rem 0.4rem !important; }
  td.actions-cell .icon-btn { margin:0 0.1rem; vertical-align:middle; }
  th.actions-head { text-align:center; vertical-align:middle; width:80px; min-width:80px; }
  /* Ensure all table cells align middle */
  table td { vertical-align:middle; }
  /* Loading state for action buttons */
  .icon-btn[disabled] { opacity:0.6; cursor:not-allowed; transform:none; }
  .icon-btn.loading { position:relative; color:transparent; }
  .icon-btn.loading::after { content:""; width:14px; height:14px; border:2px solid #cbd5e1; border-top-color:#2563eb; border-radius:50%; animation:spin .8s linear infinite; position:absolute; }
  /* Inline spinner for status banner */
  .inline-spinner { width:14px; height:14px; border:2px solid #86efac; border-top-color:#166534; border-radius:50%; display:inline-block; animation:spin .8s linear infinite; margin-right:6px; vertical-align:middle; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .floating-trash { position:fixed; bottom:1.5rem; right:8.5rem; background:#1e293b; color:#f8fafc; padding:0.6rem 0.9rem; border-radius:999px; display:flex; align-items:center; gap:0.5rem; box-shadow:0 10px 25px rgba(15,23,42,0.25); text-decoration:none; font-size:0.9rem; }
  .floating-trash:hover { background:#0f172a; }
  .floating-trash .count { background:#facc15; color:#1e293b; padding:0 0.6rem; border-radius:999px; font-weight:600; }
  .floating-block { position:fixed; bottom:1.5rem; right:1.5rem; background:#0ea5e9; color:#f0f9ff; padding:0.6rem 0.9rem; border-radius:999px; display:flex; align-items:center; gap:0.5rem; box-shadow:0 10px 25px rgba(14,165,233,0.35); text-decoration:none; font-size:0.9rem; }
  .floating-block:hover { background:#0284c7; }
  .floating-block .icon { display:inline-flex; align-items:center; justify-content:center; }
  .floating-block .icon svg { width:16px; height:16px; display:block; }
  /* Drawer styles */
  .drawer-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.45); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:1000; }
  .drawer { position:fixed; top:0; right:-520px; width:520px; max-width:92vw; height:100%; background:#0b1220; color:#e2e8f0; border-left:1px solid rgba(148,163,184,0.2); box-shadow: -12px 0 30px rgba(0,0,0,0.35); transition:right .22s ease; z-index:1001; display:flex; flex-direction:column; }
  .drawer.open { right:0; }
  .drawer-backdrop.open { opacity:1; pointer-events:auto; }
  .drawer header { display:flex; align-items:center; justify-content:space-between; padding:0.8rem 1rem; border-bottom:1px solid rgba(148,163,184,0.2); }
  .drawer .close-btn { background:#1f2937; color:#e5e7eb; border:none; padding:0.35rem 0.6rem; border-radius:6px; cursor:pointer; font-size:0.85rem; }
  .drawer .close-btn:hover { background:#111827; }
  .drawer .content { flex:1; }
  .drawer .content iframe { width:100%; height:100%; border:0; }
    .footer { margin-top:3rem; font-size:0.7rem; color:#777; }
    form.inline { display:inline; }
    nav.pagination { margin-top:1rem; display:flex; gap:0.4rem; flex-wrap:wrap; }
    nav.pagination a { padding:4px 8px; text-decoration:none; border:1px solid #bbb; border-radius:4px; font-size:0.75rem; color:#222; background:#fff; }
    nav.pagination a.active { background:#2563eb; color:#fff; border-color:#2563eb; }
    nav.pagination a:hover { background:#1d4ed8; color:#fff; }
    .wrap { white-space:pre-wrap; word-break:break-word; }
    /* Expand/collapse content buttons */
    .content-cell { position: relative; }
    .content-text { white-space: pre-wrap; word-break: break-word; }
    .content-truncated { max-height: none; }
    .expand-btn { background: none; border: none; color: #2563eb; cursor: pointer; font-size: 0.75rem; padding: 2px 6px; margin-left: 4px; border-radius: 4px; }
    .expand-btn:hover { background: #e0ecff; text-decoration: underline; }
    /* Hide legacy pagination for infinite scroll UX */
    nav.pagination { display:none !important; }
  /* Infinite loader */
  #infiniteLoader { display:none; align-items:center; justify-content:center; gap:.5rem; color:#334155; font-size:.85rem; padding:1rem 0; }
    #infiniteLoader .spinner { width:16px; height:16px; border:2px solid #cbd5e1; border-top-color:#2563eb; border-radius:50%; animation:spin .8s linear infinite; }
  /* End-of-list */
  #endOfList { display:none; text-align:center; color:#475569; font-size:.85rem; padding:0.25rem 0 1.25rem; }
  /* Scroll container for posts only */
  #postsScroll { flex:1; overflow:auto; margin-top:.5rem; background:#fff; border:1px solid #e2e8f0; border-radius:8px; padding:0 .5rem; }
  #postsScroll table { margin-top:.5rem; }
  /* Animation progressive pour l'affichage des posts */
  @keyframes fadeSlideIn { 
    from { opacity:0; transform:translateY(15px); }
    to { opacity:1; transform:translateY(0); }
  }
  tr.post-animate { animation: fadeSlideIn 0.3s ease forwards; opacity:0; }
    /* Neutral header link styling (no blue, no underline) */
    th a { color:#222; text-decoration:none; display:flex; align-items:center; gap:4px; }
    th a:visited { color:#222; }
    th a:hover { text-decoration:none; color:#1d4ed8; }
    /* Search highlight */
    .search-highlight { background:#fef08a; padding:1px 2px; border-radius:2px; }
    /* M√©tier badge styling */
    .metier-badge { display:inline-block; padding:3px 8px; border-radius:12px; font-size:0.75rem; font-weight:500; background:#e0f2fe; color:#0369a1; border:1px solid #7dd3fc; }
    /* Inline badges and sublines */
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:.7rem; line-height:1; border:1px solid #cbd5e1; background:#eef2f5; color:#334155; }
    .pill-opp { background:#dcfce7; border-color:#86efac; color:#166534; font-weight:600; }
    .pill-intent-rp { background:#1e3a8a; color:#fff; border-color:#1e3a8a; font-weight:600; }
    .pill-intent-autre { background:#64748b; color:#fff; border-color:#64748b; }
    .meta-sub { display:block; font-size:.75rem; color:#64748b; margin-top:2px; }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:space-between; gap:1rem;">
    <h1 style="margin:0;">LinkedIn Scraper Titan</h1>
    <div class="actions" style="margin-top:0;">
      <form id="exportForm" class="inline" action="/export/excel" method="get">
        <input type="hidden" name="q" value="{{ q or '' }}" />
        <input type="hidden" name="sort_by" value="{{ sort_by }}" />
        <input type="hidden" name="sort_dir" value="{{ sort_dir }}" />
        <input type="hidden" name="page" value="1" />
  <button type="submit" id="exportBtn" class="btn-outline"><span id="exportBtnText">Exporter au format Excel</span><span id="exportBtnSpinner" class="inline-spinner" style="display:none;margin-left:6px;"></span></button>
      </form>
      <button id="logoutBtn" type="button" class="btn-outline">Se d√©connecter</button>
    </div>
  </div>

  <div id="statusContainer" data-interval="{{ autonomous_interval or 0 }}" data-init-wait="{{ login_initial_wait_seconds or 120 }}" style="margin-top:0.75rem; font-size:0.9rem; display:flex; align-items:center; gap:.75rem;">
  <div id="statusHint" class="status-hint status-hint-wait" aria-live="polite"><span class="inline-spinner" aria-hidden="true"></span>Initialisation‚Ä¶</div>
  </div>
  <style>
  /* Status line removed; only hint banner remains */
  </style>
  <script>
    // Toast system
    const _toastQ = [];
    function showToast(msg, type='info'){ // type: info|error|success
      let c = document.getElementById('toastContainer');
      if(!c){
        c = document.createElement('div');
        c.id='toastContainer';
        c.style.cssText='position:fixed;top:1rem;right:1rem;display:flex;flex-direction:column;gap:.5rem;z-index:1000;';
        document.body.appendChild(c);
      }
      const div = document.createElement('div');
      div.textContent = msg;
      div.style.cssText='padding:.6rem .9rem;border-radius:6px;font-size:.75rem;box-shadow:0 2px 6px rgba(0,0,0,.15);color:#fff;opacity:0;transform:translateY(-6px);transition:all .25s;';
      const colors = {info:'#2563eb', success:'#15803d', error:'#b91c1c'};
      div.style.background = colors[type]||colors.info;
      c.appendChild(div);
      requestAnimationFrame(()=>{div.style.opacity='1';div.style.transform='translateY(0)';});
      setTimeout(()=>{div.style.opacity='0';div.style.transform='translateY(-6px)'; setTimeout(()=>div.remove(),300);}, 3400);
    }

    // ========== SESSION RECONNECT MODALS ==========
    function showReconnectModal(payload) {
      // Remove existing modal if any
      const existing = document.getElementById('reconnectModal');
      if (existing) existing.remove();
      
      const modal = document.createElement('div');
      modal.id = 'reconnectModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1001;';
      modal.innerHTML = `
        <div style="background:#fff;border-radius:12px;padding:2rem;max-width:400px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
          <div style="font-size:3rem;margin-bottom:1rem;">‚ùå</div>
          <h3 style="color:#b91c1c;margin-bottom:1rem;">Session expir√©e</h3>
          <p style="color:#666;margin-bottom:1.5rem;">${payload.message || 'La reconnexion automatique a √©chou√©. Veuillez vous reconnecter manuellement.'}</p>
          <div style="display:flex;gap:1rem;justify-content:center;">
            <a href="/login?reason=session_revoked" style="background:#2563eb;color:#fff;padding:0.75rem 1.5rem;border-radius:8px;text-decoration:none;font-weight:500;">Se reconnecter</a>
            <button onclick="document.getElementById('reconnectModal').remove()" style="background:#e5e7eb;padding:0.75rem 1.5rem;border-radius:8px;border:none;cursor:pointer;">Fermer</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    // Desktop local hardening: per-launch token to prevent drive-by POSTs to localhost
    const DESKTOP_TRIGGER_KEY = "{{ desktop_trigger_key|default('')|e }}";
    function desktopHeaders(extra){
      const h = extra ? { ...extra } : {};
      if (DESKTOP_TRIGGER_KEY) h['X-Desktop-Trigger'] = DESKTOP_TRIGGER_KEY;
      return h;
    }
    
    function showHumanValidationModal(payload) {
      // Remove existing modal if any
      const existing = document.getElementById('humanValidationModal');
      if (existing) existing.remove();
      
      const modal = document.createElement('div');
      modal.id = 'humanValidationModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1001;';
      modal.innerHTML = `
        <div style="background:#fff;border-radius:12px;padding:2rem;max-width:450px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
          <div style="font-size:3rem;margin-bottom:1rem;">üîê</div>
          <h3 style="color:#f59e0b;margin-bottom:1rem;">Validation humaine requise</h3>
          <p style="color:#666;margin-bottom:0.5rem;">LinkedIn demande une v√©rification de s√©curit√© :</p>
          <ul style="text-align:left;color:#666;margin:1rem 0;padding-left:1.5rem;">
            <li>CAPTCHA (puzzle visuel)</li>
            <li>V√©rification par email/SMS</li>
            <li>Authentification √† deux facteurs (2FA)</li>
          </ul>
          <p style="color:#666;margin-bottom:1.5rem;font-size:0.9rem;">Veuillez vous connecter manuellement pour r√©soudre cette v√©rification.</p>
          <div style="display:flex;gap:1rem;justify-content:center;">
            <a href="/login" style="background:#f59e0b;color:#fff;padding:0.75rem 1.5rem;border-radius:8px;text-decoration:none;font-weight:500;">Connexion manuelle</a>
            <button onclick="document.getElementById('humanValidationModal').remove()" style="background:#e5e7eb;padding:0.75rem 1.5rem;border-radius:8px;border:none;cursor:pointer;">Fermer</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    async function attemptAutoReconnect() {
      showToast('üîÑ Tentative de reconnexion automatique...', 'info');
      try {
        const resp = await fetch('/api/session/auto_reconnect', { method: 'POST', headers: desktopHeaders() });
        const data = await resp.json();
        if (data.ok) {
          showToast('‚úÖ Reconnexion r√©ussie!', 'success');
          await refreshStatus();
          // Close any open modals
          const modal = document.getElementById('reconnectModal');
          if (modal) modal.remove();
        } else if (data.needs_human_validation) {
          showHumanValidationModal(data);
        } else {
          showToast('‚ùå ' + (data.error || '√âchec'), 'error');
        }
      } catch (e) {
        showToast('‚ùå Erreur: ' + e, 'error');
      }
    }
    
    function showAccountRestrictedModal(payload) {
      // Remove existing modal if any
      const existing = document.getElementById('accountRestrictedModal');
      if (existing) existing.remove();
      
      const modal = document.createElement('div');
      modal.id = 'accountRestrictedModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:1001;';
      modal.innerHTML = `
        <div style="background:#fff;border-radius:12px;padding:2rem;max-width:500px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
          <div style="font-size:4rem;margin-bottom:1rem;">üö´</div>
          <h3 style="color:#b91c1c;margin-bottom:1rem;">Compte LinkedIn Temporairement Bloqu√©</h3>
          <p style="color:#666;margin-bottom:1rem;">LinkedIn a d√©tect√© une activit√© d'automatisation et a temporairement bloqu√© votre compte.</p>
          <div style="background:#fef2f2;border:1px solid #fecaca;border-radius:8px;padding:1rem;margin-bottom:1.5rem;text-align:left;">
            <p style="color:#b91c1c;font-weight:500;margin-bottom:0.5rem;">‚ö†Ô∏è Actions recommand√©es :</p>
            <ul style="color:#666;margin:0;padding-left:1.5rem;font-size:0.9rem;">
              <li><strong>Attendez 24-48h</strong> avant de r√©utiliser le scraper</li>
              <li>Connectez-vous manuellement sur LinkedIn.com pour v√©rifier</li>
              <li>La restriction est g√©n√©ralement lev√©e apr√®s quelques heures</li>
              <li>Le scraping a √©t√© automatiquement d√©sactiv√©</li>
              <li>Vos cookies de session ont √©t√© supprim√©s par s√©curit√©</li>
            </ul>
          </div>
          <p style="color:#999;font-size:0.85rem;margin-bottom:1.5rem;">${payload.reason || ''}</p>
          <div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;">
            <a href="https://www.linkedin.com" target="_blank" style="background:#0a66c2;color:#fff;padding:0.75rem 1.5rem;border-radius:8px;text-decoration:none;font-weight:500;">V√©rifier sur LinkedIn</a>
            <a href="/login?reason=account_restricted" style="background:#dc2626;color:#fff;padding:0.75rem 1.5rem;border-radius:8px;text-decoration:none;font-weight:500;">Aller √† la page de connexion</a>
            <button onclick="document.getElementById('accountRestrictedModal').remove()" style="background:#e5e7eb;padding:0.75rem 1.5rem;border-radius:8px;border:none;cursor:pointer;">Fermer</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    // Periodic status ticker (keeps ETA/countdowns fresh without reload)
    let _statusTicker = null;
    function startStatusTicker(){
      if(_statusTicker) return;
      const tick = async ()=>{
        if(document.visibilityState === 'visible'){
          try { await refreshStatus(); } catch(_) {}
        }
      };
      _statusTicker = setInterval(tick, 5000);
    }
    function stopStatusTicker(){ if(_statusTicker){ clearInterval(_statusTicker); _statusTicker=null; } }
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible'){ startStatusTicker(); }
      else { /* optional: keep running but could pause to save CPU */ }
    });

    const hintEl = document.getElementById('statusHint');
    function setHint(text, variant='status-hint-wait'){
      if(!hintEl) return;
      // Plain text (no spinner)
      hintEl.textContent = text;
      hintEl.className = 'status-hint ' + variant;
    }
    function setHintHTML(html, variant='status-hint-wait'){
      if(!hintEl) return;
      hintEl.innerHTML = html;
      hintEl.className = 'status-hint ' + variant;
    }
    function setHintVisible(visible){
      if(!hintEl) return;
      hintEl.style.display = visible ? 'block' : 'none';
    }
    function setHintAppend(text){
      if(!hintEl) return;
      hintEl.innerHTML = text;
    }

    /**
     * Format publication date for display
     * Shows relative time (e.g., "il y a 2 jours") + absolute date
     */
    function formatPublicationDate(publishedAt, collectedAt) {
      const dateVal = publishedAt || collectedAt;
      if (!dateVal) return '‚Äî';
      
      try {
        const pubDate = new Date(dateVal);
        if (isNaN(pubDate.getTime())) return dateVal;
        
        const now = new Date();
        const diffMs = now - pubDate;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        
        let relativeStr = '';
        if (diffMinutes < 1) {
          relativeStr = "√† l'instant";
        } else if (diffMinutes < 60) {
          relativeStr = `il y a ${diffMinutes} min`;
        } else if (diffHours < 24) {
          relativeStr = `il y a ${diffHours}h`;
        } else if (diffDays === 1) {
          relativeStr = 'hier';
        } else if (diffDays < 7) {
          relativeStr = `il y a ${diffDays} jours`;
        } else if (diffDays < 14) {
          relativeStr = 'il y a 1 sem';
        } else if (diffDays < 21) {
          relativeStr = `il y a ${Math.floor(diffDays / 7)} sem`;
        } else {
          relativeStr = `il y a ${Math.floor(diffDays / 7)} sem`;
        }
        
        // Absolute date (short format)
        const absDate = pubDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
        
        // Combine: "il y a 2 jours (15/01)"
        return `<span title="${pubDate.toLocaleString('fr-FR')}">${relativeStr} <small style="color:#888">(${absDate})</small></span>`;
      } catch (_) {
        return dateVal || '‚Äî';
      }
    }

    /**
     * Toggle content expansion (Voir plus / Voir moins)
     */
    function toggleContent(contentId) {
      const span = document.getElementById(contentId);
      if (!span) return;
      const btn = document.querySelector(`button[data-target="${contentId}"]`);
      const isExpanded = span.getAttribute('data-expanded') === 'true';
      
      if (isExpanded) {
        // Collapse: show short version
        span.innerHTML = span.getAttribute('data-short');
        span.setAttribute('data-expanded', 'false');
        if (btn) btn.textContent = 'Voir plus';
      } else {
        // Expand: show full version
        span.innerHTML = span.getAttribute('data-full');
        span.setAttribute('data-expanded', 'true');
        if (btn) btn.textContent = 'Voir moins';
      }
    }

    function updateTrashBadge(count){
      const badge = document.getElementById('trashCountBadge');
      if(!badge) return;
      const value = Number.isFinite(count) ? count : 0;
      badge.textContent = value;
    }

    function updateBlockedBadge(count){
      const badge = document.getElementById('blockedCountBadge');
      if(!badge) return;
      const value = Number.isFinite(count) ? count : 0;
      badge.textContent = value;
    }

    async function refreshBlockedCount(){
      try{
        const r = await fetch('/blocked-accounts/count', { credentials:'include', headers: desktopHeaders() });
        if(!r.ok) return;
        const data = await r.json();
        updateBlockedBadge(data.count ?? 0);
      }catch(_){ /* ignore */ }
    }

    async function refreshTrashCount(){
      try {
        const r = await fetch('/api/trash/count', { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        updateTrashBadge(data.count ?? 0);
      } catch(_) { /* ignore */ }
    }

    async function handleFavorite(postId, makeFav){
      try {
        const r = await fetch(`/api/posts/${postId}/favorite`, {
          method: 'POST',
          credentials: 'include',
          headers: desktopHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ favorite: !!makeFav })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        // some servers may return no body
        try { await r.json(); } catch(_) { /* ignore */ }
        showToast('Statut favori mis √† jour','success');
      } catch(e){
        showToast('Erreur favori: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    async function handleDelete(postId){
      try {
        const r = await fetch(`/api/posts/${postId}/delete`, {
          method: 'POST',
          headers: desktopHeaders({ 'Content-Type': 'application/json' }),
          credentials: 'include',
          body: JSON.stringify({ delete: true })
        });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        let data = {};
        try { data = await r.json(); } catch(_) { /* ignore */ }
        showToast('Post d√©plac√© dans la corbeille','info');
        if(data && typeof data.trash_count !== 'undefined'){
          updateTrashBadge(data.trash_count);
        }
      } catch(e){
        showToast('Erreur suppression: '+e,'error');
      } finally {
        await refreshPosts();
      }
    }

    // Event delegation for actions (bind once at document level so it works even if table is rendered later)
    let _actionsDelegationBound = false;
    function setupActionDelegation(){
      if(_actionsDelegationBound) return;
      _actionsDelegationBound = true;
      document.addEventListener('click', async (ev)=>{
        const target = ev.target;
        if(!(target instanceof Element)) return;
        const btn = target.closest('button.favorite-toggle, button.delete-post');
        if(!btn) return;
        ev.preventDefault();
        ev.stopPropagation();
        const id = btn.getAttribute('data-id');
        if(!id) return;
        btn.classList.add('loading');
        btn.setAttribute('disabled','true');
        try {
          if(btn.classList.contains('favorite-toggle')){
            const makeFav = !btn.classList.contains('active');
            await handleFavorite(id, makeFav);
          } else if(btn.classList.contains('delete-post')){
            await handleDelete(id);
          }
        } finally {
          btn.classList.remove('loading');
          btn.removeAttribute('disabled');
        }
      });
    }

    let _initCountdownHandle = null;
    let _initLeft = null;
    // Countdown removed: immediate trigger + spinner feedback instead
    function startInitCountdown(){}
    function stopInitCountdown(){ if(_initCountdownHandle){ clearInterval(_initCountdownHandle); _initCountdownHandle=null; } _initLeft = null; }

    let _autoTriggeredFirstRun = false;
    let _autoPulseHandle = null;
    let _autoPulseBusy = false;
    function ensureAutoPulse(enabled, interval){
      // If server-side autonomous interval is 0, set up a gentle client-side pulse (every 180s)
      if(!enabled) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(interval > 0) { if(_autoPulseHandle){ clearInterval(_autoPulseHandle); _autoPulseHandle=null; } return; }
      if(_autoPulseHandle) return;
      _autoPulseHandle = setInterval(async ()=>{
        if(_autoPulseBusy) return;
        _autoPulseBusy = true;
        try {
          const r = await fetch('/health');
          if(!r.ok){ _autoPulseBusy=false; return; }
          const data = await r.json();
          // Only trigger if scraping enabled and last run not too recent
          const age = typeof data.last_run_age_seconds === 'number' ? data.last_run_age_seconds : 999999;
          if(data.scraping_enabled && age >= 150){
            try {
              const fd = new FormData();
              await fetch('/trigger', { method:'POST', body: fd, headers: desktopHeaders({ 'X-Trigger-From': 'dashboard' }) });
            } catch(_) {}
          }
        } catch(_) { /* ignore */ }
        finally { _autoPulseBusy = false; }
      }, 180000);
    }
    async function refreshStatus(){
      try {
        const r = await fetch('/health');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        // Disabled reasons: hard flag or reload auto-disable (health can expose later if added)
        if(data.scraping_enabled === false && data.disabled_flag){
          setHint('Scraper d√©sactiv√© (mode maintenance)', 'status-hint-wait');
          setHintVisible(true);
          return;
        }
        if(data.playwright_available === false){
          setHint('Mode lecture seule: Playwright indisponible', 'status-hint-error');
          setHintVisible(true);
        }
        const btn = document.getElementById('toggleBtn');
        const enabled = data.scraping_enabled;
        const interval = Number(document.getElementById('statusContainer').dataset.interval || 0);
        const baseText = "Scraper actif - Laissez l'application ouverte pour collecter automatiquement de nouveaux posts.";
        const spinner = '<span class="inline-spinner" aria-hidden="true"></span>';
        let html = '';
        if (enabled) {
          if (data.last_run_age_seconds !== undefined) {
            if (interval > 0) {
              const eta = Math.max(interval - (data.last_run_age_seconds % interval), 1);
              const perMinPosts = (typeof data.last_job_posts === 'number' && data.last_job_posts >= 0) ? (data.last_job_posts * 60 / interval) : null;
              if (perMinPosts !== null) {
                html = `${spinner}${baseText} ¬∑ ~${perMinPosts.toFixed(1)} posts/min`;
              } else {
                html = `${spinner}${baseText}`;
              }
            } else {
              html = `${spinner}${baseText}`;
            }
            ensureAutoPulse(true, interval);
            setHintHTML(html, 'status-hint-ok');
            setHintVisible(true);
          } else {
            // Initial: immediate launch message with spinner (no artificial wait)
            setHintHTML(`${spinner}${baseText}`, 'status-hint-ok');
            setHintVisible(true);
            if (!_autoTriggeredFirstRun) {
              _autoTriggeredFirstRun = true;
              try {
                const fd = new FormData();
                const tr = await fetch('/trigger', { method:'POST', body: fd, headers: desktopHeaders({ 'X-Trigger-From': 'dashboard' }) });
                if (tr.ok) { showToast('Cycle lanc√©','info'); }
              } catch(_) { /* ignore */ }
            }
            ensureAutoPulse(true, interval);
          }
          if (btn) { btn.textContent = 'Mettre en pause'; btn.style.background = '#dc2626'; }
        } else {
          // Paused: show hint as paused
          setHint('Scraper en pause', 'status-hint-wait');
          setHintVisible(true);
          if (btn) { btn.textContent = 'Reprendre'; btn.style.background = '#16a34a'; }
          if (_autoPulseHandle) { clearInterval(_autoPulseHandle); _autoPulseHandle = null; }
        }
        // Append last run info (preserve spinner if present)
        if (enabled && data.last_run && data.last_job_posts !== undefined) {
          try {
            const d = new Date(data.last_run);
            const localeStr = d.toLocaleString('fr-FR', { dateStyle:'short', timeStyle:'short' });
            const current = hintEl.innerHTML;
            setHintHTML(`${current} ¬∑ dernier run: ${localeStr} (${data.last_job_posts} posts)`, hintEl.className.replace('status-hint ','').trim());
          } catch(_) {
            const current = hintEl.innerHTML;
            setHintHTML(`${current} ¬∑ dernier run: ${data.last_run} (${data.last_job_posts} posts)`, hintEl.className.replace('status-hint ','').trim());
          }
        }
      } catch(e){
        // Health unavailable -> show error banner only
        setHint('Statut indisponible ‚Äì v√©rifiez les logs', 'status-hint-error');
        setHintVisible(true);
      }
    }
    async function toggleScraping(){
      const btn = document.getElementById('toggleBtn');
      if (btn) { btn.disabled = true; btn.textContent = 'Veuillez patienter‚Ä¶'; }
      try {
        const r = await fetch('/toggle', { method:'POST', credentials: 'include', headers: desktopHeaders() });
        if(r.status === 401){ showToast('Authentification requise - rechargement‚Ä¶','error'); location.reload(); return; }
        if(!r.ok) throw new Error('HTTP '+r.status);
        await refreshStatus();
        showToast('√âtat mis √† jour','success');
      } catch(e){
        showToast('Erreur toggle: '+e,'error');
      } finally {
        if (btn) { btn.disabled = false; }
        // refreshStatus already set final text
      }
    }
    const _toggleEl = document.getElementById('toggleBtn');
    if (_toggleEl) _toggleEl.addEventListener('click', toggleScraping);
    
    // ========== QUEUE POUR AFFICHAGE PROGRESSIF DES POSTS SSE ==========
    const _postQueue = [];
    let _postQueueRunning = false;
    const _POST_DISPLAY_DELAY = 150; // ms entre chaque post
    
    function _queueNewPost(post) {
      _postQueue.push(post);
      if (!_postQueueRunning) {
        _processPostQueue();
      }
    }
    
    async function _processPostQueue() {
      if (_postQueueRunning) return;
      _postQueueRunning = true;
      
      while (_postQueue.length > 0) {
        const p = _postQueue.shift();
        _displayNewPost(p);
        if (_postQueue.length > 0) {
          await new Promise(r => setTimeout(r, _POST_DISPLAY_DELAY));
        }
      }
      
      _postQueueRunning = false;
    }
    
    function _displayNewPost(p) {
      const tbody = document.querySelector('table tbody');
      if (!tbody) return;
      
      // Check if post already exists
      if (document.querySelector(`tr[data-post-id="${p._id}"]`)) return;
      
      const rowHTML = _rowHTML({
        _id: p._id,
        keyword: p.keyword,
        author: p.author,
        company: p.company,
        permalink: p.permalink,
        text: p.text,
        published_at: p.published_at,
        collected_at: p.collected_at,
        metier: p.metier,
        is_favorite: 0
      });
      
      // Insert at the top of the table with animation
      const tmp = document.createElement('tbody');
      tmp.innerHTML = rowHTML;
      const row = tmp.firstChild;
      if (row) {
        row.classList.add('post-animate');
        // Insert at top (sorted by most recent)
        const firstRow = tbody.querySelector('tr');
        if (firstRow) {
          tbody.insertBefore(row, firstRow);
        } else {
          tbody.appendChild(row);
        }
      }
    }
    // ========== FIN QUEUE AFFICHAGE PROGRESSIF ==========
    
    // Auto refresh posts if a new run detected
    let _lastRunSeen = null;
    async function refreshPosts(){
      try {
        const url = new URL(window.location.href);
        const page = url.searchParams.get('page') || '1';
        const limit = url.searchParams.get('limit') || '20';
        const q = encodeURIComponent(url.searchParams.get('q')||'');
        const sortBy = encodeURIComponent(url.searchParams.get('sort_by')||'');
        const sortDir = encodeURIComponent(url.searchParams.get('sort_dir')||'');
  const r = await fetch(`/api/posts?page=${page}&limit=${limit}&q=${q}&sort_by=${sortBy}&sort_dir=${sortDir}`, { credentials: 'include' });
        if(!r.ok) return;
        const data = await r.json();
        const tbody = document.querySelector('table tbody');
        if(!tbody) return;
        if(data.items.length === 0){
          // Ne pas afficher le message si le tableau a d√©j√† des posts
          if(tbody.children.length === 0 || tbody.innerHTML.includes('Aucun r√©sultat')){
            tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;font-size:0.8rem;color:#555;">Aucun r√©sultat pour le moment.</td></tr>';
          }
          return;
        }
        // Supprimer le message "Aucun r√©sultat" s'il existe
        const noResultRow = tbody.querySelector('tr td[colspan]');
        if(noResultRow && noResultRow.textContent.includes('Aucun r√©sultat')){
          noResultRow.parentElement.remove();
        }
        const rows = data.items.map(p=>{
          const txt = (p.text||'');
          const short = txt.length>200? txt.substring(0,200)+'‚Ä¶' : txt;
          const dateFmt = formatPublicationDate(p.published_at, p.collected_at);
          const searchFallback = `https://www.linkedin.com/search/results/content/?keywords=${encodeURIComponent((txt||p.author||'').slice(0,80))}`;
          const permalink = p.permalink ? `<a href="${p.permalink}" target="_blank">ouvrir</a>` : `<a href="${searchFallback}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>`;
          const keywordSub = p.keyword ? `<div class="meta-sub" title="Mot-cl√© de recherche">${String(p.keyword||'').replace(/</g,'&lt;')}</div>` : '';
          const starActive = Number(p.is_favorite || 0) === 1;
          const starClass = starActive ? 'icon-btn favorite-toggle active' : 'icon-btn favorite-toggle';
          const starTitle = starActive ? 'Retirer des favoris' : 'Marquer en favori';
          return `<tr data-post-id="${p._id}">
            <td>${(p.author||'').replace(/\b(\w+\s+\w+)\s+\1\b/gi,'$1')}${keywordSub}</td>
            <td>${(p.company&&p.company.toLowerCase()!==String(p.author||'').toLowerCase())?p.company:'‚Äî'}</td>
            <td class="content-cell wrap">${short.replace(/</g,'&lt;')}</td>
            <td>${dateFmt}</td>
            <td>${permalink}</td>
            <td class="actions-cell">
              <button type="button" class="${starClass}" data-id="${p._id}" title="${starTitle}">‚òÖ</button>
              <button type="button" class="icon-btn delete-post" data-id="${p._id}" title="Supprimer ce post">üóë</button>
            </td>
          </tr>`;
        }).join('');
        tbody.innerHTML = rows;
        // No need to rebind per-row handlers thanks to event delegation
      } catch(e){ /* silent */ }
    }
      // ---------- Infinite scroll state + renderer ----------
      const _state = {
        page: 1,
        limit: 30,
        q: new URL(window.location.href).searchParams.get('q') || '',
        sort_by: '{{ sort_by }}' || 'published_at',
        sort_dir: '{{ sort_dir }}' || 'desc',
        loading: false,
        done: false,
      };

      function safeEncodeURI(str) {
        try {
          return encodeURIComponent(str || '');
        } catch(e) {
          // Fallback: remove problematic characters
          return encodeURIComponent((str || '').replace(/[^\x00-\x7F]/g, ''));
        }
      }

      // Remove key emoji (üîë) from text content
      function removeKeyEmoji(text) {
        return (text || '').replace(/üîë/g, '').trim();
      }

      // Generate unique ID for content expansion
      let _contentIdCounter = 0;
      function _genContentId() {
        return 'content-' + (++_contentIdCounter);
      }

      function _rowHTML(p){
        // Remove key emoji from text
        const txt = removeKeyEmoji(p.text||'');
        const needsExpand = txt.length > 200;
        const short = needsExpand ? txt.substring(0,200) + '‚Ä¶' : txt;
        const contentId = _genContentId();
        const dateFmt = formatPublicationDate(p.published_at, p.collected_at);
        const searchFallback = `https://www.linkedin.com/search/results/content/?keywords=${safeEncodeURI((txt||p.author||'').slice(0,80))}`;
        const permalink = p.permalink ? `<a href="${p.permalink}" target="_blank">ouvrir</a>` : `<a href="${searchFallback}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>`;
        // Keyword as subtitle under author
        const keywordSub = p.keyword ? `<div class="meta-sub" title="Mot-cl√© de recherche">${String(p.keyword||'').replace(/</g,'&lt;')}</div>` : '';
        const starActive = Number(p.is_favorite || 0) === 1;
        const starClass = starActive ? 'icon-btn favorite-toggle active' : 'icon-btn favorite-toggle';
        const starTitle = starActive ? 'Retirer des favoris' : 'Marquer en favori';
        const companyCell = (p.company&&String(p.company).toLowerCase()!==String(p.author||'').toLowerCase())?p.company:'‚Äî';
        // Content cell with expand/collapse functionality
        const escapedShort = short.replace(/</g,'&lt;');
        const escapedFull = txt.replace(/</g,'&lt;');
        const contentCell = needsExpand
          ? `<td class="content-cell wrap"><span id="${contentId}" class="content-text" data-full="${escapedFull.replace(/"/g,'&quot;')}" data-short="${escapedShort.replace(/"/g,'&quot;')}" data-expanded="false">${escapedShort}</span><button type="button" class="expand-btn" data-target="${contentId}" onclick="toggleContent('${contentId}')">Voir plus</button></td>`
          : `<td class="content-cell wrap"><span class="content-text">${escapedShort}</span></td>`;
        return `<tr data-post-id="${p._id}">
          <td>${(p.author||'').replace(/\b(\w+\s+\w+)\s+\1\b/gi,'$1')}${keywordSub}</td>
          <td>${companyCell}</td>
          ${contentCell}
          <td>${dateFmt}</td>
          <td>${permalink}</td>
          <td class="actions-cell">
            <button type="button" class="${starClass}" data-id="${p._id}" title="${starTitle}">‚òÖ</button>
            <button type="button" class="icon-btn delete-post" data-id="${p._id}" title="Supprimer ce post">üóë</button>
          </td>
        </tr>`;
      }

      function _setLoader(visible){
        const el = document.getElementById('infiniteLoader');
        if(el){ el.style.display = visible ? 'flex' : 'none'; }
      }

      function _setEndOfList(visible){
        const el = document.getElementById('endOfList');
        if(el){ el.style.display = visible ? 'block' : 'none'; }
      }

      async function loadNextPage(){
        if(_state.loading || _state.done) return;
        _state.loading = true;
        _setLoader(true);
        try {
          const q = encodeURIComponent(_state.q||'');
          const sortBy = encodeURIComponent(_state.sort_by||'');
          const sortDir = encodeURIComponent(_state.sort_dir||'');
          console.log('[DEBUG] Fetching posts page', _state.page);
          const r = await fetch(`/api/posts?page=${_state.page}&limit=${_state.limit}&q=${q}&sort_by=${sortBy}&sort_dir=${sortDir}`, { credentials: 'include' });
          console.log('[DEBUG] Response status:', r.status);
          if(!r.ok){ _state.done = true; console.error('[DEBUG] Response not OK'); return; }
          const data = await r.json();
          console.log('[DEBUG] Got items:', data.items ? data.items.length : 0);
          const items = Array.isArray(data.items) ? data.items : [];
          const tbody = document.querySelector('table tbody');
          if(!tbody) return;
          if(_state.page === 1 && items.length === 0){
            // Ne pas afficher le message si le tableau a d√©j√† des posts
            if(tbody.children.length === 0 || tbody.innerHTML.includes('Aucun r√©sultat')){
              tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;font-size:0.8rem;color:#555;">Aucun r√©sultat pour le moment.</td></tr>';
            }
            _state.done = true;
            _setEndOfList(false);
            return;
          }
          // Supprimer le message "Aucun r√©sultat" s'il existe
          const noResultRow = tbody.querySelector('tr td[colspan]');
          if(noResultRow && noResultRow.textContent.includes('Aucun r√©sultat')){
            noResultRow.parentElement.remove();
          }
          if(items.length > 0){
            if(_state.page === 1 && tbody.children.length > 0){ tbody.innerHTML = ''; }
            // Affichage progressif : ajouter les posts un par un avec animation
            for(let i = 0; i < items.length; i++){
              const rowHTML = _rowHTML(items[i]);
              const tmp = document.createElement('tbody'); tmp.innerHTML = rowHTML;
              const row = tmp.firstChild;
              if(row){
                row.classList.add('post-animate');
                row.style.animationDelay = (i * 80) + 'ms';
                tbody.appendChild(row);
              }
            }
            _state.page += 1;
            if(items.length < _state.limit){ _state.done = true; }
            // hide end-of-list if we just appended more
            _setEndOfList(false);
          } else {
            _state.done = true;
          }
        } catch(e){ console.error('[DEBUG] loadNextPage error:', e); }
        finally {
          _state.loading = false; _setLoader(false);
          // show end-of-list if done and there is at least one row
          try {
            const tbody = document.querySelector('table tbody');
            const hasRows = !!(tbody && tbody.querySelector('tr'));
            _setEndOfList(_state.done && hasRows);
          } catch(_) {}
        }
      }

      function resetAndLoad(){
        const tbody = document.querySelector('table tbody');
        if(tbody) tbody.innerHTML = '';
        _state.page = 1; _state.done = false; _setEndOfList(false); loadNextPage();
      }
      
      // Fonction pour supprimer le message "Aucun r√©sultat" si des posts sont affich√©s
      function removeNoResultMessage(){
        const tbody = document.querySelector('table tbody');
        if(!tbody) return;
        const allRows = tbody.querySelectorAll('tr');
        let hasRealPosts = false;
        allRows.forEach(row => {
          const colspan = row.querySelector('td[colspan]');
          if(!colspan || !colspan.textContent.includes('Aucun r√©sultat')){
            hasRealPosts = true;
          }
        });
        if(hasRealPosts){
          allRows.forEach(row => {
            const colspan = row.querySelector('td[colspan]');
            if(colspan && colspan.textContent.includes('Aucun r√©sultat')){
              row.remove();
            }
          });
        }
      }
      
      // Ex√©cuter au chargement pour nettoyer tout message r√©siduel
      document.addEventListener('DOMContentLoaded', removeNoResultMessage);

      // Override previous refreshPosts to perform a reset reload
      async function refreshPosts(){ resetAndLoad(); }

      // Scroll listener (on posts container only)
      let _scrollBind = false;
      function bindInfiniteScroll(){
        if(_scrollBind) return; _scrollBind = true;
        const scroller = document.getElementById('postsScroll');
        const onScroll = ()=>{
          if(!scroller) return;
          const nearBottom = (scroller.scrollTop + scroller.clientHeight) >= (scroller.scrollHeight - 300);
          if(nearBottom){ loadNextPage(); }
        };
        if(scroller){ scroller.addEventListener('scroll', onScroll); }
      }
    function setupSSE(){
      try {
        const es = new EventSource('/stream');
        es.onmessage = async (ev)=>{
          try {
            const payload = JSON.parse(ev.data);
            if(payload.type === 'new_post' && payload.post){
              // Progressive display: add new post to the table with staggered delay
              _queueNewPost(payload.post);
            } else if(payload.type === 'job_complete'){
              // Ne pas recharger les posts - ils ont √©t√© ajout√©s progressivement via SSE
              await refreshStatus();
              await refreshTrashCount();
              showToast(`Cycle termin√© (${payload.posts} posts)`, 'info');
              // Keep guidance visible in active mode
              setHint('Laissez l\'application ouverte pour collecter automatiquement de nouveaux posts.', 'status-hint-ok');
              setHintVisible(true);
            } else if (payload.type === 'toggle') {
              await refreshStatus();
              showToast(payload.scraping_enabled ? 'Scraper repris' : 'Scraper en pause', payload.scraping_enabled ? 'success' : 'info');
            } else if (payload.type === 'session_revoked') {
              // Session r√©voqu√©e par LinkedIn
              showToast('‚ö†Ô∏è Session LinkedIn r√©voqu√©e - Tentative de reconnexion...', 'error');
              setHint('Session LinkedIn r√©voqu√©e. Reconnexion en cours...', 'status-hint-error');
              setHintVisible(true);
            } else if (payload.type === 'session_reconnecting') {
              showToast('üîÑ Reconnexion en cours avec vos identifiants sauvegard√©s...', 'info');
            } else if (payload.type === 'session_reconnect_success') {
              showToast('‚úÖ Reconnexion r√©ussie! Le scraping reprend.', 'success');
              setHint('Reconnexion r√©ussie - Scraping en cours', 'status-hint-ok');
              await refreshStatus();
            } else if (payload.type === 'session_reconnect_failed') {
              showToast('‚ùå √âchec de la reconnexion: ' + (payload.message || 'erreur inconnue'), 'error');
              setHint('Reconnexion √©chou√©e - Veuillez vous reconnecter manuellement', 'status-hint-error');
              setHintVisible(true);
              showReconnectModal(payload);
            } else if (payload.type === 'human_validation_required') {
              showToast('üîê Validation humaine requise (CAPTCHA/2FA)', 'error');
              setHint('Validation humaine requise - Cliquez pour vous reconnecter manuellement', 'status-hint-error');
              setHintVisible(true);
              showHumanValidationModal(payload);
            } else if (payload.type === 'account_restricted') {
              showToast('üö´ COMPTE RESTREINT par LinkedIn!', 'error');
              setHint('‚ö†Ô∏è Compte LinkedIn temporairement restreint - Scraping arr√™t√© automatiquement', 'status-hint-error');
              setHintVisible(true);
              showAccountRestrictedModal(payload);
            }
          } catch(e){ /* ignore JSON parse */ }
          if(payload && payload.type === 'purge'){
            await refreshPosts();
            showToast('Base purg√©e ('+ (payload.removed_sqlite||0) +' supprim√©s)', 'success');
          }
        };
        es.onerror = ()=>{
          // Fallback: restart after delay (will rely on polling if fails repeatedly)
          showToast('SSE coup√© - fallback polling','error');
          setHint('Flux SSE interrompu ‚Äì passage en mode polling', 'status-hint-error');
          es.close();
          startPollingFallback();
        };
      } catch(e){
        startPollingFallback();
      }
    }
    let _pollHandle = null;
    function startPollingFallback(){
      if(_pollHandle) return;
      _pollHandle = setInterval(async ()=>{
        try {
          const r = await fetch('/health');
          if(r.ok){
            const data = await r.json();
            if(data.last_run && data.last_run !== _lastRunSeen){
              if(_lastRunSeen !== null){
                await refreshPosts();
                showToast('Nouveaux posts charg√©s (poll)','info');
              }
              _lastRunSeen = data.last_run;
            }
          }
        } catch(_){ }
        refreshStatus();
      }, 10000);
    }
    
  // ========== POLLING RAPIDE DES NOUVEAUX POSTS ==========
  // Pendant le scraping, on poll toutes les 2s pour afficher les posts au fur et √† mesure
  let _lastSeenPostId = null;
  let _rapidPollHandle = null;
  let _rapidPollActive = false;
  
  function startRapidPostPolling() {
    if (_rapidPollHandle) return;
    _rapidPollActive = true;
    console.log('[RapidPoll] Started');
    
    _rapidPollHandle = setInterval(async () => {
      if (!_rapidPollActive) return;
      try {
        // Fetch latest posts (just first page, sorted by most recent)
        const r = await fetch('/api/posts?page=1&limit=20&sort_by=collected_at&sort_dir=desc', { credentials: 'include' });
        if (!r.ok) return;
        const data = await r.json();
        if (!data.items || !data.items.length) return;
        
        // Find new posts not yet displayed
        const tbody = document.querySelector('table tbody');
        if (!tbody) return;
        
        let addedCount = 0;
        for (const p of data.items) {
          // Skip if already displayed
          if (document.querySelector(`tr[data-post-id="${p._id}"]`)) continue;
          
          // Add with animation
          const rowHTML = _rowHTML(p);
          const tmp = document.createElement('tbody');
          tmp.innerHTML = rowHTML;
          const row = tmp.firstChild;
          if (row) {
            row.classList.add('post-animate');
            // Insert at top
            const firstRow = tbody.querySelector('tr');
            if (firstRow) {
              tbody.insertBefore(row, firstRow);
            } else {
              tbody.appendChild(row);
            }
            addedCount++;
          }
        }
        
        if (addedCount > 0) {
          console.log('[RapidPoll] Added', addedCount, 'new posts');
        }
      } catch (e) {
        console.warn('[RapidPoll] Error:', e);
      }
    }, 1000); // Poll every 1 second for real-time display
  }
  
  function stopRapidPostPolling() {
    _rapidPollActive = false;
    if (_rapidPollHandle) {
      clearInterval(_rapidPollHandle);
      _rapidPollHandle = null;
      console.log('[RapidPoll] Stopped');
    }
  }
  
  // Start rapid polling on page load (scraping is active by default)
  startRapidPostPolling();
  // ========== FIN POLLING RAPIDE ==========
  
  refreshStatus();
  setupSSE();
  startStatusTicker();
  setupActionDelegation();
  refreshTrashCount();
  refreshBlockedCount();
  setInterval(refreshBlockedCount, 15000);
  // Drawer logic
  const blockBtn = document.getElementById('floatingBlock');
  const drawer = document.getElementById('blockedDrawer');
  const backdrop = document.getElementById('drawerBackdrop');
  const closeBtn = document.getElementById('drawerCloseBtn');
  function openDrawer(){ if(drawer && backdrop){ drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false'); backdrop.classList.add('open'); backdrop.setAttribute('aria-hidden','false'); var cb = document.getElementById('drawerCloseBtn'); if(cb){ try{ cb.focus(); }catch(_){} } } }
  function closeDrawer(){ if(drawer && backdrop){ drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true'); backdrop.classList.remove('open'); backdrop.setAttribute('aria-hidden','true'); } }
  if(blockBtn){ blockBtn.addEventListener('click', (ev)=>{ if(ev instanceof MouseEvent){ if(ev.button !== 0 || ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey){ return; } } ev.preventDefault(); openDrawer(); }); }
  if(closeBtn){ closeBtn.addEventListener('click', ()=> closeDrawer()); }
  if(backdrop){ backdrop.addEventListener('click', ()=> closeDrawer()); }
  document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape'){ closeDrawer(); } });
    // Logout handler
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async ()=>{
        logoutBtn.disabled = true;
        logoutBtn.textContent = 'D√©connexion‚Ä¶';
        try {
          await fetch('/api/session/logout', { method:'POST', headers: desktopHeaders() });
        } catch(_) { /* ignore */ }
        window.location.href = '/login';
      });
    }
    
    // Export Excel handler with loading spinner
    const exportForm = document.getElementById('exportForm');
    const exportBtn = document.getElementById('exportBtn');
    const exportBtnText = document.getElementById('exportBtnText');
    const exportBtnSpinner = document.getElementById('exportBtnSpinner');
    if (exportForm && exportBtn) {
      exportForm.addEventListener('submit', (ev) => {
        // Show loading state
        exportBtn.disabled = true;
        if(exportBtnText) exportBtnText.textContent = 'G√©n√©ration en cours‚Ä¶';
        if(exportBtnSpinner) exportBtnSpinner.style.display = 'inline-block';
        showToast('Export Excel en cours de g√©n√©ration‚Ä¶', 'info');
        
        // Reset button after download starts (form submit triggers file download)
        setTimeout(() => {
          exportBtn.disabled = false;
          if(exportBtnText) exportBtnText.textContent = 'Exporter au format Excel';
          if(exportBtnSpinner) exportBtnSpinner.style.display = 'none';
        }, 3000);
      });
    }
  </script>
  <!-- Search bar placed between status and table -->
  <div style="margin-top:1rem; display:flex; align-items:center;">
    <input id="searchInput" type="text" name="q" placeholder="Rechercher : m√©tier, auteur, entreprise..." value="{{ q or '' }}" style="flex:1; padding:.6rem .8rem; border:1px solid #cbd5e1; border-radius:8px; font-size:0.9rem; transition:border-color 0.2s, box-shadow 0.2s;" />
    <button id="searchBtn" type="button" style="margin-left:1.5rem; padding:.6rem 1.2rem; white-space:nowrap;">Rechercher</button>
    <span id="searchResultCount" style="font-size:0.8rem; color:#64748b; margin-left:1rem;"></span>
  </div>
  <style>
    #searchInput:focus { outline:none; border-color:#2563eb; box-shadow:0 0 0 3px rgba(37,99,235,0.15); }
  </style>
    <script>
      // Enhanced search with real-time filtering
      (function(){
        const input = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const resultCount = document.getElementById('searchResultCount');
        let searchDebounce = null;
        
        function doSearch(){
          _state.q = (input && input.value)||'';
          resetAndLoad();
        }
        
        // Real-time search on typing (debounced)
        if(input){
          input.addEventListener('input', ()=>{
            clearTimeout(searchDebounce);
            searchDebounce = setTimeout(doSearch, 350);
          });
          input.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Enter'){ ev.preventDefault(); clearTimeout(searchDebounce); doSearch(); }
            if(ev.key === 'Escape'){ input.value = ''; doSearch(); }
          });
        }
        if(searchBtn){ searchBtn.addEventListener('click', ()=>{ clearTimeout(searchDebounce); doSearch(); }); }
        
        // Update result count after load
        window.__updateResultCount = function(count, total){
          if(resultCount){
            if(_state.q && _state.q.trim()){
              resultCount.textContent = `${count} r√©sultat${count>1?'s':''} trouv√©${count>1?'s':''}`;
            } else {
              resultCount.textContent = total ? `${total} post${total>1?'s':''}` : '';
            }
          }
        };
      })();
    </script>
  <!-- Top-right actions moved into header -->
  <!-- Note: En cas de doublons visibles, ils sont g√©n√©ralement dus √† des posts sans lien canonique (permalink). Le worker applique d√©j√† une d√©duplication stricte par lien puis (auteur + date). -->
  <div id="postsScroll">
  <table>
    <thead>
      <tr>
        {% set nextDir = 'asc' if sort_dir=='desc' else 'desc' %}
  <th class="sortable"><a href="#" data-sort-by="author" data-label="Auteur">Auteur <span class="sort-icon">‚áÖ</span></a></th>
  <th class="sortable"><a href="#" data-sort-by="company" data-label="Entreprise">Entreprise <span class="sort-icon">‚áÖ</span></a></th>
        <th>Contenu du Post</th>
  <th class="sortable"><a href="#" data-sort-by="published_at" data-label="Date">Date <span class="sort-icon">‚áÖ</span></a></th>
  <th>Lien</th>
  <th class="actions-head">Actions</th>
      </tr>
    </thead>
    <tbody>
    {% for post in posts %}
      {% set clean_text = (post.text or '')|remove_key_emoji %}
      {% set content_id = 'jinja-content-' ~ loop.index %}
      <tr data-post-id="{{ post._id }}">
        <td>{{ post.author }}<div class="meta-sub" title="Mot-cl√© de recherche">{{ post.keyword }}</div></td>
  <td>
    {% set cc = post.company_norm or post.company %}
    {% if cc and (cc|lower) != (post.author|lower) %}{{ cc }}{% else %}‚Äî{% endif %}
  </td>
        <td class="content-cell wrap">
          {% if clean_text|length > 200 %}
            <span id="{{ content_id }}" class="content-text" data-full="{{ clean_text|e }}" data-short="{{ clean_text[:200]|e }}‚Ä¶" data-expanded="false">{{ clean_text[:200] }}‚Ä¶</span>
            <button type="button" class="expand-btn" data-target="{{ content_id }}" onclick="toggleContent('{{ content_id }}')">Voir plus</button>
          {% else %}
            <span class="content-text">{{ clean_text }}</span>
          {% endif %}
        </td>
  <td>{{ (post.published_at or post.collected_at)|fmt_date }}</td>
          <td>
            {% if post.permalink %}
              <a href="{{ post.permalink }}" target="_blank">ouvrir</a>
            {% else %}
              {# Fallback: LinkedIn search by truncated text/author to let user click anyway #}
              {% set seed = (clean_text or post.author or '')[:80] %}
              <a href="https://www.linkedin.com/search/results/content/?keywords={{ seed | urlencode }}" target="_blank" title="Lien direct introuvable - recherche approximative">rechercher</a>
            {% endif %}
          </td>
        <td class="actions-cell">
          <button type="button" class="icon-btn favorite-toggle{% if post.is_favorite %} active{% endif %}" data-id="{{ post._id }}" title="Marquer en favori">‚òÖ</button>
          <button type="button" class="icon-btn delete-post" data-id="{{ post._id }}" title="Supprimer ce post">üóë</button>
        </td>
      </tr>
    {% endfor %}
    {% if posts|length == 0 %}
      <tr id="noResultRow"><td colspan="6" style="text-align:center; font-size:0.8rem; color:#555;">Aucun r√©sultat pour le moment.</td></tr>
    {% endif %}
    </tbody>
  </table>
  <div id="infiniteLoader"><span class="spinner" aria-hidden="true"></span> Chargement‚Ä¶</div>
  <div id="endOfList">Fin de la liste</div>
  </div>
  <script>
    // Supprimer le message "Aucun r√©sultat" si des posts existent d√©j√†
    function removeNoResultIfNeeded() {
      const tbody = document.querySelector('table tbody');
      if (!tbody) return;
      // Compter les vraies lignes de posts (pas le message "Aucun r√©sultat")
      const allRows = tbody.querySelectorAll('tr');
      let realPostCount = 0;
      allRows.forEach(row => {
        // Une vraie ligne a des donn√©es de post (pas de colspan ou colspan != 7)
        const colspan = row.querySelector('td[colspan]');
        if (!colspan) {
          realPostCount++;
        }
      });
      // Si on a des vrais posts, supprimer toutes les lignes "Aucun r√©sultat"
      if (realPostCount > 0) {
        allRows.forEach(row => {
          const colspan = row.querySelector('td[colspan]');
          if (colspan && colspan.textContent.includes('Aucun r√©sultat')) {
            row.remove();
          }
        });
      }
    }
    // Ex√©cuter au chargement
    removeNoResultIfNeeded();
    // Et aussi apr√®s un court d√©lai pour s'assurer que le DOM est pr√™t
    setTimeout(removeNoResultIfNeeded, 100);
    document.addEventListener('DOMContentLoaded', removeNoResultIfNeeded);
    // Sort handling with visual feedback
    (function(){
      const headers = document.querySelectorAll('thead th a[data-sort-by]');
      
      function updateSortIndicators(){
        headers.forEach(a=>{
          const field = a.getAttribute('data-sort-by');
          const label = a.getAttribute('data-label') || 'Sort';
          const th = a.closest('th');
          const iconSpan = a.querySelector('.sort-icon');
          if(!field) return;
          
          if(_state.sort_by === field){
            const arrow = _state.sort_dir === 'asc' ? '‚ñ≤' : '‚ñº';
            if(iconSpan) iconSpan.textContent = arrow;
            if(th) th.classList.add('sort-active');
          } else {
            if(iconSpan) iconSpan.textContent = '‚áÖ';
            if(th) th.classList.remove('sort-active');
          }
        });
      }
      
      // expose for external calls if needed
      window.__updateSortIndicators = updateSortIndicators;
      
      headers.forEach(a=>{
        a.addEventListener('click', (ev)=>{
          ev.preventDefault();
          const field = a.getAttribute('data-sort-by')||'published_at';
          if(_state.sort_by === field){ 
            _state.sort_dir = (_state.sort_dir==='asc')?'desc':'asc'; 
          } else { 
            _state.sort_by = field; 
            // Default sort direction based on field type
            _state.sort_dir = (field === 'published_at' || field === 'collected_at') ? 'desc' : 'asc';
          }
          updateSortIndicators();
          resetAndLoad();
        });
      });
      
      // Initial load & bind scroll
      bindInfiniteScroll();
      // Set default sort to date descending but don't show indicator
      _state.sort_by = 'published_at';
      _state.sort_dir = 'desc';
      // Don't call updateSortIndicators() - no visual indicator by default
      resetAndLoad();
    })();
  </script>
  <a id="floatingBlock" class="floating-block" href="/blocked" title="G√©rer les comptes LinkedIn bloqu√©s" aria-label="G√©rer les comptes LinkedIn bloqu√©s">
    <span class="icon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
      </svg>
    </span>
    <span id="blockedCountBadge" style="background:#bae6fd;color:#075985;padding:0 0.5rem;border-radius:999px;font-weight:700;">0</span>
  </a>
  <a id="floatingTrash" class="floating-trash" href="/corbeille" title="Ouvrir la corbeille">
    üóëÔ∏è <span class="count" id="trashCountBadge">{{ trash_count }}</span>
  </a>
  <!-- Inline drawer for blocked accounts management -->
  <div id="drawerBackdrop" class="drawer-backdrop" aria-hidden="true"></div>
  <div id="blockedDrawer" class="drawer" role="dialog" aria-modal="true" aria-labelledby="drawerTitle" aria-hidden="true">
    <header>
      <h2 id="drawerTitle" style="margin:0;font-size:1rem;font-weight:600;">Comptes LinkedIn bloqu√©s</h2>
      <button type="button" id="drawerCloseBtn" class="close-btn" aria-label="Fermer">Fermer ‚úï</button>
    </header>
    <div class="content">
      <iframe id="drawerIframe" src="/blocked" title="Gestion des comptes bloqu√©s" loading="lazy"></iframe>
    </div>
  </div>
  
</body>
</html>